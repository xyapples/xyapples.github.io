{
    "version": "https://jsonfeed.org/version/1",
    "title": "LinuxSre云原生 • All posts by \"redis\" category",
    "description": "专注于 Linux 运维、云计算、云原⽣等技术",
    "home_page_url": "http://imxuyong.cn",
    "items": [
        {
            "id": "http://imxuyong.cn/posts/1414180692.html",
            "url": "http://imxuyong.cn/posts/1414180692.html",
            "title": "Redis集群（主从+哨兵）模式",
            "date_published": "2025-04-09T11:50:06.000Z",
            "content_html": "<h3 id=\"redis集群主从哨兵模式\"><a class=\"anchor\" href=\"#redis集群主从哨兵模式\">#</a> Redis 集群（主从 + 哨兵）模式</h3>\n<h3 id=\"一-什么是redis主从复制\"><a class=\"anchor\" href=\"#一-什么是redis主从复制\">#</a> 一、什么是 redis 主从复制？</h3>\n<p>主从复制，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为主节点 (master)，后者称为从节点 (slave), 数据的复制是单向的，只能由主节点到从节点。master 以写为主，slave 以读为主。</p>\n<p><a href=\"https://imgse.com/i/pEgTlKx\"><img loading=\"lazy\" data-src=\"https://s21.ax1x.com/2025/04/09/pEgTlKx.png\" alt=\"pEgTlKx.png\" /></a></p>\n<h3 id=\"二-主从复制的作用\"><a class=\"anchor\" href=\"#二-主从复制的作用\">#</a> 二、主从复制的作用</h3>\n<p>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。<br />\n故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。<br />\n负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。<br />\n读写分离：用于实现读写分离，主库写、从库读，读写分离不仅可以提高服务器的负载能力，同时可根据需求的变化，改变从库的数量；<br />\n高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是 Redis 高可用的基础。</p>\n<h3 id=\"三-实现主从复制\"><a class=\"anchor\" href=\"#三-实现主从复制\">#</a> 三、实现主从复制</h3>\n<table>\n<thead>\n<tr>\n<th>主机名</th>\n<th>IP</th>\n<th>角色</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>redis01</td>\n<td>192.168.40.101</td>\n<td>master</td>\n</tr>\n<tr>\n<td>redis02</td>\n<td>192.168.40.102</td>\n<td>slave</td>\n</tr>\n<tr>\n<td>redis03</td>\n<td>192.168.40.103</td>\n<td>slave</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"31-关闭防火墙-selinux\"><a class=\"anchor\" href=\"#31-关闭防火墙-selinux\">#</a> 3.1 关闭防火墙、selinux</h4>\n<pre><code>[root@master01 ~]# hostnamectl set-hostname redis01\n[root@redis01 ~]# systemctl stop firewalld\n[root@redis01 ~]# systemctl disable firewalld\n[root@redis01 ~]# sed -i 's/^SELINUX=enforcing/SELINUX=disabled/g' /etc/sysconfig/selinux\n[root@redis01 ~]# sed -i 's/^SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config\n[root@redis01 ~]# yum install net-tools vim tree lrzsz wget unzip dos2unix bash-completion  lsof ntp ntpdate git -y\n[root@redis01 ~]# yum update -y --exclude=kernel* &amp;&amp; reboot\n[root@redis01 ~]# echo 'Asia/Shanghai' &gt;/etc/timezone\n[root@redis01 ~]# ntpdate time2.aliyun.com\n[root@redis01 ~]# crontab -e\n*/5 * * * * /usr/sbin/ntpdate time2.aliyun.com &amp;&gt; /dev/null\n[root@redis01 ~]# mkdir /soft /data /scripts /backup\n</code></pre>\n<h4 id=\"32-安装redis\"><a class=\"anchor\" href=\"#32-安装redis\">#</a> 3.2 安装 redis</h4>\n<pre><code>[root@redis01 ~]# yum install gcc-c++ -y\n[root@redis01 soft]# wget https://download.redis.io/releases/redis-6.2.11.tar.gz\n[root@redis01 soft]# tar xf redis-6.2.11.tar.gz \n[root@redis01 soft]# ln -s /soft/redis-6.2.11 /soft/redis\n[root@redis01 soft]# cd /soft/redis\n[root@redis01 redis]# make            #执行make编译\n[root@redis01 redis]# make install    #将 src下的许多可执行文件复制到/usr/local/bin 目录下\n[root@redis01 redis]# redis-server /soft/redis/redis.conf &amp;\n[root@redis01 redis]# netstat -lntp|grep redis\ntcp        0      0 127.0.0.1:6379          0.0.0.0:*               LISTEN      69686/redis-server  \ntcp6       0      0 ::1:6379                :::*                    LISTEN      69686/redis-server     \n[root@redis01 redis]# redis-cli shutdown      #关闭Redis服务\n</code></pre>\n<h4 id=\"33-redis配置文件说明\"><a class=\"anchor\" href=\"#33-redis配置文件说明\">#</a> 3.3 redis 配置文件说明</h4>\n<pre><code>[root@db01 redis]# vim redis.conf \nbind 127.0.0.1      \t\t# 绑定的ip\nprotected-mode yes  \t\t# 保护模式\nport 6379           \t\t# 端口设置\ndaemonize yes               # 后台启动\nbind 127.0.0.1      \t\t# 绑定的ip\nprotected-mode yes  \t\t# 保护模式\nport 6379           \t\t# 端口设置\nloglevel notice     \t\t# 记录日志级别\nlogfile &quot;redis.log&quot;         # 日志的文件位置名\ndir ./               \t\t# 日志存储目录\ndatabases 16        \t\t# 数据库的数量，默认是 16 个数据库\nalways-show-logo yes \t\t# 是否总是显示LOGO\n\n# 如果900s内，如果至少有一个1 key进行了修改，我们及进行持久化操作\nsave 900 1\n# 如果300s内，如果至少10 key进行了修改，我们及进行持久化操作\nsave 300 10\n# 如果60s内，如果至少10000 key进行了修改，我们及进行持久化操作\nsave 60 10000\n# 我们之后学习持久化，会自己定义这个测试！\nstop-writes-on-bgsave-error yes   # 持久化如果出错，是否还需要继续工作！\nrdbcompression yes                # 是否压缩 rdb 文件，需要消耗一些cpu资源！\nrdbchecksum yes                   # 保存rdb文件的时候，进行错误的检查校验！\ndbfilename dump.rdb               # rdb 文件保存的名称！\ndir ./                            # rdb 文件保存的目录！\n\nslaveof 192.168.1.154 6379        # 配置主从复制\nrequirepass foobared              # 配置redis登录密码\n\nappendonly no    # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用！\nappendfilename &quot;appendonly.aof&quot;   # 持久化的文件的名字\n# appendfsync always        # 每次修改都会 sync。消耗性能\nappendfsync everysec        # 每秒执行一次 sync，可能会丢失这1s的数据！\n# appendfsync no            # 不执行 sync，这个时候操作系统自己同步数据，速度最快！\nno-appendfsync-on-rewrite   #重写时是否可以运用appendsync，默认no，可以保证数据的安全性\n</code></pre>\n<h4 id=\"34-redis环境配置\"><a class=\"anchor\" href=\"#34-redis环境配置\">#</a> 3.4 redis 环境配置</h4>\n<p>#修改 maser 配置文件</p>\n<pre><code>vim redis.conf\nbind 192.168.40.101 #绑定本机ip地址\nport 6739          #绑定端口号\ndaemonize yes      #用来指定redis是否要用守护进程的方式启动，默认为no\npidfile /var/run/redis_6379.pid\nlogfile &quot;redis.log&quot;   #redis日志文件\nrequirepass Superman*2023  #本地redis密码\nmasterauth Superman*2023   #主节点redis密码 注意:从节点也要配置，后边哨兵容灾切换用到\nprotected-mode yes    #保护模式\n</code></pre>\n<p>#修改 slave01 配置文件</p>\n<pre><code>vim redis.conf\nbind 192.168.40.102 #绑定本机ip地址\nport 6739          #绑定端口号\ndaemonize yes      #用来指定redis是否要用守护进程的方式启动，默认为no\npidfile /var/run/redis_6379.pid\nlogfile &quot;redis.log&quot;   #redis日志文件\nreplicaof  192.168.40.101 6379 #配置文件中设置主节点，redis主从复制这个地方只配置从库，注意:主库不需要这个配置\nrequirepass Superman*2023  #本地redis密码\nmasterauth Superman*2023   #主节点redis密码 注意:从节点也要配置，后边哨兵容灾切换用到\nprotected-mode yes    #保护模式\n</code></pre>\n<p>#修改 slave02 配置文件</p>\n<pre><code>vim redis.conf\nbind 192.168.40.103 #绑定本机ip地址\nport 6739          #绑定端口号\ndaemonize yes      #用来指定redis是否要用守护进程的方式启动，默认为no\npidfile /var/run/redis_6379.pid\nlogfile &quot;redis.log&quot;   #redis日志文件\nreplicaof  192.168.40.101 6379 #配置文件中设置主节点，redis主从复制这个地方只配置从库，注意:主库不需要这个配置\nrequirepass Superman*2023  #本地redis密码\nmasterauth Superman*2023   #主节点redis密码 注意:从节点也要配置，后边哨兵容灾切换用到\nprotected-mode yes    #保护模式\n</code></pre>\n<h4 id=\"35-启动3台redis服务\"><a class=\"anchor\" href=\"#35-启动3台redis服务\">#</a> 3.5 启动 3 台 redis 服务</h4>\n<pre><code>#启动redis01\n[root@redis01 redis]# redis-server /soft/redis/redis.conf\n[root@redis0[root@redis01 redis]# redis-server /soft/redis/redis.conf redis]# netstat -lntp|grep redis\ntcp        0      0 192.168.40.101:6379     0.0.0.0:*               LISTEN      117358/redis-server \n\n#启动redis02\n[root@redis02 redis]# redis-server /soft/redis/redis.conf\n[root@redis02 redis]# netstat -lntp|grep redis\ntcp        0      0 192.168.40.102:6379     0.0.0.0:*               LISTEN      18210/redis-server\n\n启动redis03\n[root@redis03 redis]# redis-server /soft/redis/redis.conf\n[root@redis03 redis]# netstat -lntp|grep redis\ntcp        0      0 192.168.40.103:6379     0.0.0.0:*               LISTEN      19186/redis-server \n</code></pre>\n<h4 id=\"36-查看主从状态\"><a class=\"anchor\" href=\"#36-查看主从状态\">#</a> 3.6 查看主从状态</h4>\n<pre><code>#主节点\n[root@redis01 redis]# redis-cli -p 6379 -h 192.168.40.101 -a Superman*2023\n192.168.40.101:6379&gt; info replication\n# Replication\nrole:master\nconnected_slaves:2\nslave0:ip=192.168.40.102,port=6379,state=online,offset=616,lag=0\nslave1:ip=192.168.40.103,port=6379,state=online,offset=616,lag=0\nmaster_failover_state:no-failover\nmaster_replid:93df7cd5095dcccdbf8266787031b17cf638a2ad\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:616\nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:1\nrepl_backlog_histlen:616\n\n#从节点\n[root@redis01 redis]# redis-cli -p 6379 -h 192.168.40.103 -a Superman*2023\nWarning: Using a password with '-a' or '-u' option on the command line interface may not be safe.\n192.168.40.103:6379&gt; info replication\n# Replication\nrole:slave\nmaster_host:192.168.40.101\nmaster_port:6379\nmaster_link_status:up\nmaster_last_io_seconds_ago:1\nmaster_sync_in_progress:0\nslave_read_repl_offset:812\nslave_repl_offset:812\nslave_priority:100\nslave_read_only:1\nreplica_announced:1\nconnected_slaves:0\nmaster_failover_state:no-failover\nmaster_replid:93df7cd5095dcccdbf8266787031b17cf638a2ad\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:812\nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:295\nrepl_backlog_histlen:518\n</code></pre>\n<h4 id=\"37-测试主从\"><a class=\"anchor\" href=\"#37-测试主从\">#</a> 3.7 测试主从</h4>\n<pre><code>[root@redis01 redis]# redis-cli -p 6379 -h 192.168.40.101 -a Superman*2023\nWarning: Using a password with '-a' or '-u' option on the command line interface may not be safe.\n192.168.40.101:6379&gt; set k1 v1\nOK\n192.168.40.101:6379&gt; set k2 v2\nOK\n\n[root@redis03 redis]# redis-cli -p 6379 -h 192.168.40.103 -a Superman*2023\nWarning: Using a password with '-a' or '-u' option on the command line interface may not be safe.\n192.168.40.103:6379&gt; get k1\n&quot;v1&quot;\n192.168.40.103:6379&gt; get k2\n&quot;v2&quot;\n</code></pre>\n<p><strong>注意:</strong><br />\n1、主机可以写，从机不能写，只能读。主机中的所有数据都会保存到从机中去。<br />\n2、主机断开连接，从机依旧连接到主机的，但是没有写操作，这个时候，主机如果回来了，从机依旧可以直接获取到主机写的信息！<br />\n3、如果是使用命令行，来配置的主从，这个时候如果重启了，就会变回主机！只要变为从机，立马就会从主机中获取值！<br />\n4、主从复制原理<br />\n Slave 启动成功连接到 master 后会发送一个 sync 同步命令<br />\n Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master 将传送整个数据文件到 slave，并完成一次完全同步。<br />\n全量复制：slave 服务在接收到数据库文件数据后，将其存盘并加载到内存中。<br />\n增量复制：Master 继续将新的所有收集到的修改命令依次传给 slave，完成同步，但是只要是重新连接 master，一次完全同步（全量复制）将被自动执行！ 主机的数据一定可以在从机中看到。</p>\n<h3 id=\"四-哨兵模式搭建\"><a class=\"anchor\" href=\"#四-哨兵模式搭建\">#</a> 四、哨兵模式搭建</h3>\n<p>1、什么是 redis 哨兵？<br />\nRedisSentinel 是 Redis 的高可用性解决方案，由一个或多个 Sentinel（哨兵）实例组成。它可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，它的主要功能如下：<br />\n监控 (Monitoring)：Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。<br />\n通知 (Notification)：当被监控的某个 Redis 服务器出现问题时，Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。<br />\n故障迁移：当主服务器不能正常工作时，Sentinel 会自动进行故障迁移，也就是主从切换。<br />\n统一的配置：管理连接者询问 sentinel 取得主从的地址。</p>\n<p>2、哨兵原理是什么？<br />\nSentinel 使用的算法核心是 Raft 算法，主要用途就是用于分布式系统，系统容错，以及 Leader 选举，每个 Sentinel 都需要定期的执行以下任务：<br />\n每个 Sentinel 会自动发现其他 Sentinel 和从服务器，它以每秒钟一次的频率向它所知的主服务器、从服务器以及其他 Sentinel 实例发送一个 PING 命令。<br />\n如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 那么这个实例会被 Sentinel 标记为主观下线。 有效回复可以是： +PONG 、 -LOADING 或者 -MASTERDOWN 。<br />\n如果一个主服务器被标记为主观下线， 那么正在监视这个主服务器的所有 Sentinel 要以每秒一次的频率确认主服务器的确进入了主观下线状态。<br />\n如果一个主服务器被标记为主观下线， 并且有足够数量的 Sentinel（至少要达到配置文件指定的数量）在指定的时间范围内同意这一判断，那么这个主服务器被标记为客观下线。<br />\n在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有主服务器和从服务器发送 INFO 命令。当一个主服务器 Sentinel 标记为客观下线时，Sentinel 向下线主服务器的所有从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。<br />\n当没有足够数量的 Sentinel 同意主服务器已经下线， 主服务器的客观下线状态就会被移除。 当主服务器重新向 Sentinel 的 PING 命令返回有效回复时， 主服务器的主管下线状态就会被移除。</p>\n<p><a href=\"https://imgse.com/i/pEgT1r6\"><img loading=\"lazy\" data-src=\"https://s21.ax1x.com/2025/04/09/pEgT1r6.png\" alt=\"pEgT1r6.png\" /></a></p>\n<h4 id=\"41-搭建哨兵\"><a class=\"anchor\" href=\"#41-搭建哨兵\">#</a> 4.1 搭建哨兵</h4>\n<p><em>在每台服务器上部署一个哨兵，配置方式如下:</em></p>\n<pre><code>[root@redis01 redis]# vim sentinel.conf\n#端口默认为26379。\nport 26379\n#关闭保护模式，可以外部访问。\nprotected-mode no\n#设置为后台启动。\ndaemonize yes\n#日志文件。\nlogfile &quot;/soft/redis/sentinel.log&quot;\n#指定服务器IP地址和端口，并且指定当有2台哨兵认为主机挂了，则对主机进行容灾切换。注意:三台哨兵这里的ip配置均为主节点ip 和端口\nsentinel monitor mymaster 192.168.40.101 6379 2\n#当在Redis实例中开启了requirepass，这里就需要提供密码。\nsentinel auth-pass mymaster psw66\n#这里设置了主机多少秒无响应，则认为挂了。\nsentinel down-after-milliseconds mymaster 3000\n#主备切换时，最多有多少个slave同时对新的master进行同步，这里设置为默认的\nsnetinel parallel-syncs mymaster 1\n#故障转移的超时时间，这里设置为三分钟。\nsentinel failover-timeout mymaster 180000\n</code></pre>\n<h4 id=\"42-启动三台服务器上的哨兵\"><a class=\"anchor\" href=\"#42-启动三台服务器上的哨兵\">#</a> 4.2 启动三台服务器上的哨兵</h4>\n<pre><code>#启动redis01的sentine\n[root@redis01 redis]# redis-sentinel /soft/redis/sentinel.conf\n[root@redis01 redis]#  netstat -lntp|grep redis\ntcp        0      0 0.0.0.0:26379           0.0.0.0:*               LISTEN      33536/redis-sentine \ntcp        0      0 192.168.40.101:6379     0.0.0.0:*               LISTEN      117358/redis-server \ntcp6       0      0 :::26379                :::*                    LISTEN      33536/redis-sentine\n\n#启动redis02的sentine\n[root@redis02 redis]# redis-sentinel /soft/redis/sentinel.conf\n[root@redis02 redis]#  netstat -lntp|grep redis\ntcp        0      0 0.0.0.0:26379           0.0.0.0:*               LISTEN      18757/redis-sentine \ntcp        0      0 192.168.40.102:6379     0.0.0.0:*               LISTEN      18210/redis-server  \ntcp6       0      0 :::26379                :::*                    LISTEN      18757/redis-sentine\n\n#启动redis03的sentine\n[root@redis03 redis]# redis-sentinel /soft/redis/sentinel.conf                     \n[root@redis03 redis]# netstat -lntp|grep redis\ntcp        0      0 0.0.0.0:26379           0.0.0.0:*               LISTEN      19745/redis-sentine \ntcp        0      0 192.168.40.103:6379     0.0.0.0:*               LISTEN      19186/redis-server  \ntcp6       0      0 :::26379                :::*                    LISTEN      19745/redis-sentine\n</code></pre>\n<h4 id=\"43-连接客户端\"><a class=\"anchor\" href=\"#43-连接客户端\">#</a> 4.3 连接客户端</h4>\n<pre><code>[root@redis01 redis]# redis-cli -p 26379\n127.0.0.1:26379&gt;  info sentinel\n# Sentinel\nsentinel_masters:1\nsentinel_tilt:0\nsentinel_running_scripts:0\nsentinel_scripts_queue_length:0\nsentinel_simulate_failure_flags:0\nmaster0:name=mymaster,status=ok,address=192.168.40.101:6379,slaves=2,sentinels=3\n</code></pre>\n<h4 id=\"44-redis容灾切换\"><a class=\"anchor\" href=\"#44-redis容灾切换\">#</a> 4.4 redis 容灾切换</h4>\n<pre><code>#连接redis客户端\n[root@redis01 redis]# redis-cli -p 6379 -h 192.168.40.101 \n#验证密码\n192.168.40.101:6379&gt; auth Superman*2023\nOK\n#关闭redis服务\n192.168.40.101:6379&gt; shutdown\nnot connected&gt;\n#退出客户端\nnot connected&gt; exit\n</code></pre>\n<p>关闭主节点之后，我们去查看哨兵日志:</p>\n<pre><code>[root@redis01 ~]# tail -f /soft/redis/sentinel.log \n91936:X 14 Apr 2023 23:26:23.838 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\n91936:X 14 Apr 2023 23:26:23.838 # Redis version=6.2.11, bits=64, commit=00000000, modified=0, pid=91936, just started\n91936:X 14 Apr 2023 23:26:23.838 # Configuration loaded\n91936:X 14 Apr 2023 23:26:23.838 * monotonic clock: POSIX clock_gettime\n91936:X 14 Apr 2023 23:26:23.839 * Running mode=sentinel, port=26379.\n91936:X 14 Apr 2023 23:26:23.839 # Sentinel ID is 835b4c8544fb250af5fd479f834ee369cc4f388e\n91936:X 14 Apr 2023 23:26:23.839 # +monitor master mymaster 192.168.40.101 6379 quorum 2\n\n\n\n91936:X 14 Apr 2023 23:31:25.329 # +sdown master mymaster 192.168.40.101 6379   #这里应该是发现主节点宕机\n91936:X 14 Apr 2023 23:31:25.359 # +new-epoch 5\n91936:X 14 Apr 2023 23:31:25.360 # +vote-for-leader ab43979285cb47b1b459aeb0ab91b63fa9d1a989 5\n91936:X 14 Apr 2023 23:31:25.401 # +odown master mymaster 192.168.40.101 6379 #quorum 3/2 两个哨兵都觉得主节点宕机了\n91936:X 14 Apr 2023 23:31:25.401 # Next failover delay: I will not start a failover before Fri Apr 14 23:37:25 2023\n91936:X 14 Apr 2023 23:31:26.468 # +config-update-from sentinel ab43979285cb47b1b459aeb0ab91b63fa9d1a989 192.168.40.102 26379 @ mymaster 192.168.40.101 6379\n91936:X 14 Apr 2023 23:31:26.468 # +switch-master mymaster 192.168.40.101 6379 192.168.40.103 6379 #通过投票选举40.103为新的主节点\n91936:X 14 Apr 2023 23:31:26.468 * +slave slave 192.168.40.102:6379 192.168.40.102 6379 @ mymaster 192.168.40.103 6379\n91936:X 14 Apr 2023 23:31:26.469 * +slave slave 192.168.40.101:6379 192.168.40.101 6379 @ mymaster 192.168.40.103 6379\n</code></pre>\n<p>下面我们去 40.103 下查看哨兵主从切换是否成功</p>\n<pre><code>[root@redis03 redis]# redis-cli -p 6379 -h 192.168.40.103\n192.168.40.103:6379&gt; auth Superman*2023\nOK\n192.168.40.103:6379&gt; info replication\n# Replication\nrole:master   # 40.103变成主节点了\nconnected_slaves:1   # 下面的从机个数为1\nslave0:ip=192.168.40.102,port=6379,state=online,offset=108708,lag=1\nmaster_failover_state:no-failover\nmaster_replid:cf36f762dcae0c07b54f7287dc19d7ecc0d50dd3\nmaster_replid2:a7de32d10b2d31f8886c84ca91dc7f055439c935\nmaster_repl_offset:108851\nsecond_repl_offset:59887\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:1\nrepl_backlog_histlen:108851\n</code></pre>\n<p>重新连接挂掉的主节点</p>\n<pre><code>[root@redis01 redis]# redis-server redis.conf \n[root@redis01 redis]#  redis-cli -p 6379 -h 192.168.40.101\n192.168.40.101:6379&gt; auth Superman*2023\nOK\n192.168.40.101:6379&gt; info replication\n# Replication\nrole:slave          #主节点连接回来之后自动变成了从节点，并且成功连上了主机\nmaster_host:192.168.40.103\nmaster_port:6379\nmaster_link_status:up\nmaster_last_io_seconds_ago:1\nmaster_sync_in_progress:0\nslave_read_repl_offset:130607\nslave_repl_offset:130607\nslave_priority:100\nslave_read_only:1\nreplica_announced:1\nconnected_slaves:0\nmaster_failover_state:no-failover\nmaster_replid:cf36f762dcae0c07b54f7287dc19d7ecc0d50dd3\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:130607\nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:126982\nrepl_backlog_histlen:3626\n</code></pre>\n<p>再去主节点确认一下</p>\n<pre><code>192.168.40.103:6379&gt; info replication\n# Replication\nrole:master\nconnected_slaves:2   #两个从节点\nslave0:ip=192.168.40.102,port=6379,state=online,offset=147879,lag=1\nslave1:ip=192.168.40.101,port=6379,state=online,offset=147879,lag=1\nmaster_failover_state:no-failover\nmaster_replid:cf36f762dcae0c07b54f7287dc19d7ecc0d50dd3\nmaster_replid2:a7de32d10b2d31f8886c84ca91dc7f055439c935\nmaster_repl_offset:148165\nsecond_repl_offset:59887\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:1\nrepl_backlog_histlen:148165\n</code></pre>\n<p>五、哨兵模式的优缺点<br />\n 1. 优点</p>\n<p>哨兵集群，基于主从复制模式，所有的主从配置优点，它全有</p>\n<p>主从可以切换，故障可以转移，系统的可用性就会更好</p>\n<p>哨兵模式就是主从模式的升级，手动到自动，更加健壮！</p>\n<p>2. 缺点</p>\n<p>Redis 不好在线扩容，集群容量一旦到达上限，在线扩容就十分麻烦</p>\n<p>哨兵模式的配置繁琐</p>\n<p>3. 哨兵模式的配置文件详解</p>\n<pre><code># Example sentinel.conf\n# 哨兵sentinel实例运行的端口 默认26379\nport 26379\n \n# 哨兵sentinel的工作目录\ndir /tmp\n \n# 哨兵sentinel监控的redis主节点的 ip port\n# master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。\n# quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了\n# sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;\nsentinel monitor mymaster 127.0.0.1 6379 2\n  \n# 当在Redis实例中开启了requirepass foobared 授权密码这样所有连接Redis实例的客户端都要提供 密码\n# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码\n# sentinel auth-pass &lt;master-name&gt; &lt;password&gt;\nsentinel auth-pass mymaster MySUPER--secret-0123passw0rd\n \n# 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时哨兵主观上认为主节点下线 默认30秒\n# sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;\nsentinel down-after-milliseconds mymaster 30000\n \n# 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成failover所需的时间就越长， 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。 可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。\n# sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;\nsentinel parallel-syncs mymaster 1\n \n# 故障转移的超时时间 failover-timeout 可以用在以下这些方面：\n#1. 同一个sentinel对同一个master两次failover之间的间隔时间。\n#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那 里同步数据时。\n#3.当想要取消一个正在进行的failover所需要的时间。\n#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时， slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了 # 默认三分钟\n# sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt; bilibili：\nsentinel failover-timeout mymaster 180000\n \n# SCRIPTS EXECUTION\n#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知 相关人员。\n#对于脚本的运行结果有以下规则：\n#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10\n#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。\n#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。\n#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。\n#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等）， 将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信 息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配 置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无 法正常启动成功。\n#通知脚本\n# shell编程\n# sentinel notification-script &lt;master-name&gt; &lt;script-path&gt; sentinel\nnotification-script mymaster /var/redis/notify.sh\n \n# 客户端重新配置主节点参数脚本\n# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已 经发生改变的信息。\n# 以下参数将会在调用脚本时传给脚本:\n# &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt; # 目前&lt;state&gt;总是“failover”,\n# &lt;role&gt;是“leader”或者“observer”中的一个。\n# 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通 信的# 这个脚本应该是通用的，能被多次调用，不是针对性的。\n# sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt; sentinel client-reconfig-\nscript mymaster /var/redis/reconfig.sh\n</code></pre>\n<p><em>再去看一下 redis 的配置文件和哨兵的配置文件，你会惊讶的发现，里边的配置文件已经被改过来了。</em></p>\n<pre><code>cat redis.con\n...\nreplicaof 192.168.40.103 6379\n</code></pre>\n",
            "tags": [
                "Redis"
            ]
        }
    ]
}