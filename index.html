<!-- build time:Sun Sep 07 2025 21:59:36 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"><meta name="renderer" content="webkit"><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon.ico"><link rel="alternate" href="/rss.xml" title="LinuxSre云原生" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="LinuxSre云原生" type="application/atom+xml"><link rel="alternate" type="application/json" title="LinuxSre云原生" href="http://ixuyong.cn/feed.json"><link rel="preconnect" href="https://s4.zstatic.net"><link rel="preconnect" href="https://at.alicdn.com"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CFredericka%20the%20Great:400,400italic,700,700italic%7CNoto%20Serif%20JP:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CInconsolata:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" media="none" onload="this.media&#x3D;&#39;all&#39;"><link rel="stylesheet" href="/css/app.css?v=0.4.17"><link rel="modulepreload" href="/js/chunk-GV364XSK.js"><link rel="modulepreload" href="/js/chunk-NYSE5UKM.js"><link rel="modulepreload" href="/js/chunk-RONCYO2S.js"><link rel="modulepreload" href="/js/chunk-THHXCRSX.js"><link rel="modulepreload" href="/js/chunk-WIQECBEN.js"><link rel="modulepreload" href="/js/comments-DL2IYMPZ.js"><link rel="modulepreload" href="/js/copy-tex-NADCTXPG.js"><link rel="modulepreload" href="/js/post-DA635IH6.js"><link rel="modulepreload" href="/js/quicklink-WEDHL4BA.js"><link rel="modulepreload" href="/js/search-VCZRKTM5.js"><link rel="modulepreload" href="/js/siteInit.js"><link rel="modulepreload" href="/js/waline-NNBYRQEE.js"><link rel="stylesheet" href="/css/comments-F4ZGS7LD.css" media="none" onload="this.media&#x3D;&#39;all&#39;"><link rel="stylesheet" href="/css/siteInit.css" media="none" onload="this.media&#x3D;&#39;all&#39;"><link rel="stylesheet" href="/css/waline-IDNZKML2.css" media="none" onload="this.media&#x3D;&#39;all&#39;"><link rel="preload" href="https://s21.ax1x.com/2025/03/29/pEsS0hD.png" as="image" fetchpriority="high"><meta name="description" content="专注于 Linux 运维、云计算、云原⽣等技术"><link rel="canonical" href="http://ixuyong.cn/"><title>LinuxSre云原生 = 致力于技术布道、普及前沿技术、打造云原生系列标杆博客</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><a class="logo" href="/" rel="start"><h1 class="title" itemprop="name headline">LinuxSre云原生</h1></a><p class="meta" itemprop="description">= 致力于技术布道、普及前沿技术、打造云原生系列标杆博客 =</p></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">LinuxSre云原生</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><img src="https://s21.ax1x.com/2025/03/29/pEsS0hD.png" loading="eager" decoding="async" fetchpriority="high" alt="LinuxSre云原生"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="index wrap"><h2 class="divider">置顶文章</h2><div class="segments sticky"><article class="item"><div class="cover"><a href="/posts/2170503498.html" itemprop="url" title="Nginx高可用-Keepalived（十三）"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/rosAXRD.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-09-07 20:57:55"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-09-07T20:57:55+08:00">2025-09-07</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>12k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>11 分钟</span></span></div><h3><a href="/posts/2170503498.html" itemprop="url" title="Nginx高可用-Keepalived（十三）">Nginx高可用-Keepalived（十三）</a></h3><div class="excerpt"># Nginx 高可用 - Keepalived # **1.** 高可用基本概述 # 1.1 什么是高可用 简单理解：两台机器启动着相同的业务系统，当有一台机器宕机，另外一台服务器能快速的接管，对于访问的用户是无感知的； 专业理解：高可用是分布式系统架构设计中必要的一环，主要目的：减少系统不能提供服务的时间。假设系统一直能够提供服务，我们说系统的可用性是 100%。如果系统每运行 100 个时间单位，会有 1 个时间单位无法提供服务，我们说系统的可用性是 99%； 高可用的目的：减少系统 down 机时间，提高 SLA 服务等级； # 1.2 高可用使用什么工具 通常服务高可</div><div class="meta footer"><span><a href="/categories/Nginx/" itemprop="url" title="Nginx"><i class="ic i-flag"></i>Nginx</a></span></div><a href="/posts/2170503498.html" class="btn" itemprop="url" title="Nginx高可用-Keepalived（十三）">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/449551545.html" itemprop="url" title="Nginx安全-HTTPS加密实践（十二）"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/IT5J7Eo.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-09-03 19:27:33"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-09-03T19:27:33+08:00">2025-09-03</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>12k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>11 分钟</span></span></div><h3><a href="/posts/449551545.html" itemprop="url" title="Nginx安全-HTTPS加密实践（十二）">Nginx安全-HTTPS加密实践（十二）</a></h3><div class="excerpt"># Nginx 安全 - HTTPS 加密实践 # 1.HTTPS 基本概述 # 1.1 为何需要 HTTPS 因为 HTTP 采用的是明文传输数据，那么在传输（账号密码、交易信息、等敏感数据）时不安全。容易遭到篡改，如果使用 HTTPS 协议，数据在传输过程中是加密的，能够有效避免网站传输时信息泄露 # 1.2 什么是 HTTPS HTTPS 安全的超文本传输协议，我们现在大部分站点都是通过 HTTPS 来实现站点数据安全。 早期网景公司设计了 SSL（Secure Socket Layer）安全套接层协议，主要对 HTTP 协议传输的数据进行加密。那如何将站点变成安全的 HTTPS 站点</div><div class="meta footer"><span><a href="/categories/Nginx/" itemprop="url" title="Nginx"><i class="ic i-flag"></i>Nginx</a></span></div><a href="/posts/449551545.html" class="btn" itemprop="url" title="Nginx安全-HTTPS加密实践（十二）">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/245964480.html" itemprop="url" title="Nginx Rewrite场景实战（十一）"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/t6MQ7jn.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-09-02 19:25:18"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-09-02T19:25:18+08:00">2025-09-02</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>21k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>19 分钟</span></span></div><h3><a href="/posts/245964480.html" itemprop="url" title="Nginx Rewrite场景实战（十一）">Nginx Rewrite场景实战（十一）</a></h3><div class="excerpt"># Nginx Rewrite 场景实战 # 1.Rewrite 基本介绍 # 1.1 什么是 Rewrite Rewrite 主要实现 url 地址重写， 以及 url 地址跳转。就是将用户请求 web 服务器的 URL 地址重新修改为其他 URL 地址的过程。 比如说京东，google、亚马逊都在使用 域名 重写后域名 www.z.cn www.amazon.cn www.g.cn www.google.cn www.360buy.com www.jd.com 58.com bj.58.com # 1.2 Rewrite 应用场景 1. 地址跳转，用户访问</div><div class="meta footer"><span><a href="/categories/Nginx/" itemprop="url" title="Nginx"><i class="ic i-flag"></i>Nginx</a></span></div><a href="/posts/245964480.html" class="btn" itemprop="url" title="Nginx Rewrite场景实战（十一）">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/2674400645.html" itemprop="url" title="Nginx代理-Uwsgi实践(十)"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/B6jS6Oz.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-09-01 19:21:48"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-09-01T19:21:48+08:00">2025-09-01</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>6.3k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>6 分钟</span></span></div><h3><a href="/posts/2674400645.html" itemprop="url" title="Nginx代理-Uwsgi实践(十)">Nginx代理-Uwsgi实践(十)</a></h3><div class="excerpt"># Nginx 代理 - Uwsgi 实践 # 1. Uwsgi 代理基本概述 # 1.1 什么是 wsgi WSGI，全称 Web Server Gateway Interface 是为 Python 语言定义的 Web 服务器 和 Web 应用程序之间的一种简单通用的接口。 WSGI 的官方定义，the Python Web ServerGateway Interface。从名字就可以看出来，这是一个 Gateway 网关。那么网关的作用就是在协议之间进行转换。 也就是说，WSGI 就像是一座桥梁，一边连着 web 服务器，另一边连着 web 应用程序。 # 1.2 什么是 uWSG</div><div class="meta footer"><span><a href="/categories/Nginx/" itemprop="url" title="Nginx"><i class="ic i-flag"></i>Nginx</a></span></div><a href="/posts/2674400645.html" class="btn" itemprop="url" title="Nginx代理-Uwsgi实践(十)">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/2279050448.html" itemprop="url" title="Nginx代理-动静分离(九)"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/e2ZROM5.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-09-01 19:18:51"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-09-01T19:18:51+08:00">2025-09-01</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>4.7k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>4 分钟</span></span></div><h3><a href="/posts/2279050448.html" itemprop="url" title="Nginx代理-动静分离(九)">Nginx代理-动静分离(九)</a></h3><div class="excerpt"># Nginx 代理 - 动静分离 # 1. 动静分离基本介绍 # 1.1 什么是动静分离 简单来说就是将动态请求和静态请求分开处理。 # 1.2 为何需要动静分离 首先 Tomcat 应用服务器在处理静态资源时效率不高，但默认情况下无论 “动态、静态 “ 资源都是由 tomcat 处理，而 Tomcat 在处理静态资源时需要进行逻辑运算，从而会导致应用响应慢，并且会占用不必要的系统资源。 那么借助 Nginx 实现动态资源请求和静态资源请求分离后，可以减少系统不必要的消耗和延时。以便加快系统的处理性能。 # 1.3 如何实现动静分离 Nginx 通过用户请求的 uri 来区分请求的类型，</div><div class="meta footer"><span><a href="/categories/Nginx/" itemprop="url" title="Nginx"><i class="ic i-flag"></i>Nginx</a></span></div><a href="/posts/2279050448.html" class="btn" itemprop="url" title="Nginx代理-动静分离(九)">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/1240534980.html" itemprop="url" title="Nginx TCP四层负载均衡(八)"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/LTue1Xw.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-08-31 21:40:01"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-08-31T21:40:01+08:00">2025-08-31</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>4k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>4 分钟</span></span></div><h3><a href="/posts/1240534980.html" itemprop="url" title="Nginx TCP四层负载均衡(八)">Nginx TCP四层负载均衡(八)</a></h3><div class="excerpt"># Nginx TCP 四层负载均衡 # 1. 四层负载均衡基本概述 # 1.1 什么是四层负载均衡 所谓四层就是基于 * IP+* 端口的负载均衡，它通过用户请求的端口来决定将请求转发至哪台后端服务器。 就是通过三层的 IP 地址并加上四层的端口号，来决定哪些流量需要做负载均衡。对需要负载均衡的流量进行 NAT 转换，然后转发至后端服务器节点，并记录这个 TCP 或者 UDP 的流量是由哪台后端服务器处理的，后续这个连接的所有流量都同样转发到同一台服务器处理。 # 1.2 四层负载均衡应用场景 1. 场景一、端口代理 首先 http 当然是最常用的一种协议，但是还是有很多非 http 的应用</div><div class="meta footer"><span><a href="/categories/Nginx/" itemprop="url" title="Nginx"><i class="ic i-flag"></i>Nginx</a></span></div><a href="/posts/1240534980.html" class="btn" itemprop="url" title="Nginx TCP四层负载均衡(八)">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/1868764668.html" itemprop="url" title="Nginx负载均衡基于uri调度场景（七）"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/udtexi3.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-08-31 14:45:17"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-08-31T14:45:17+08:00">2025-08-31</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>9.5k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>9 分钟</span></span></div><h3><a href="/posts/1868764668.html" itemprop="url" title="Nginx负载均衡基于uri调度场景（七）">Nginx负载均衡基于uri调度场景（七）</a></h3><div class="excerpt"># Nginx 负载均衡基于 uri 调度场景 # 1. Nginx 负载均衡调度场景 # 1.1 根据 uri 进行调度 (路由) # 1.1.1 环境准备 系统版本 主机角色 外网 IP 内网 IP 端口 CentOS7 负载均衡 10.0.0.5 172.16.1.5 80 CentOS7 提供 &#x2F;user 集群 10.0.0.7 172.16.1.7 80 CentOS7 提供 &#x2F;pass 集群 10.0.0.8 172.16.1.8 80 # 1.1.2 配置应用节点 1、web01 配置 [root@web01 conf.d]# c</div><div class="meta footer"><span><a href="/categories/Nginx/" itemprop="url" title="Nginx"><i class="ic i-flag"></i>Nginx</a></span></div><a href="/posts/1868764668.html" class="btn" itemprop="url" title="Nginx负载均衡基于uri调度场景（七）">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/2322410227.html" itemprop="url" title="Nginx负载均衡会话共享（六）"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/pLTwDv5.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-08-30 21:25:28"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-08-30T21:25:28+08:00">2025-08-30</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>4.5k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>4 分钟</span></span></div><h3><a href="/posts/2322410227.html" itemprop="url" title="Nginx负载均衡会话共享（六）">Nginx负载均衡会话共享（六）</a></h3><div class="excerpt"># Nginx 负载均衡会话共享 # 1. 什么是会话保持 当用户登陆一个网站服务器，网站服务器会将用户的登陆信息存储下来（存储下来的内容叫 Session ）以保证 我们能够一直处于 ” 登陆在线 “ 状态。 客户端：cookies 服务端：sessionID # 2. 为什么需要会话保持 由于我们使用的是负载均衡轮询机制，会导致用户请求分散在不同的节点，从而造成会话无法保持。假设用户 A，通过负载均衡登陆了网站，此时会话信息存储在 A 节点，那么当它一刷新，负载均衡会将请求分发给 B 节点，那么 B 节点没有用户 A 的登陆信息，就会提示用户 A 登陆，当 A 用户点击登陆时又会将请求</div><div class="meta footer"><span><a href="/categories/Nginx/" itemprop="url" title="Nginx"><i class="ic i-flag"></i>Nginx</a></span></div><a href="/posts/2322410227.html" class="btn" itemprop="url" title="Nginx负载均衡会话共享（六）">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/1979768636.html" itemprop="url" title="Nginx代理-负载均衡实践（五）"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/6xuaHjO.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-08-28 21:53:24"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-08-28T21:53:24+08:00">2025-08-28</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>13k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>12 分钟</span></span></div><h3><a href="/posts/1979768636.html" itemprop="url" title="Nginx代理-负载均衡实践（五）">Nginx代理-负载均衡实践（五）</a></h3><div class="excerpt"># Nginx 代理 - 负载均衡实践 # 1.Nginx 负载均衡基本概述 # 1.1 什么是负载均衡 负载均衡 Load Balance，指的是将用户访问请求所产生的流量，进行平衡，分摊到多个应用节点处理。负载均衡扩展了应用的服务能力，增强了应用的可用性。 # 1.2 为什么需要负载均 当我们的 Web 服务器直接面向用户，往往要承载大量并发请求，单台服务器难以负荷，我使用多台 WEB 服务器组成集群，前端使用 Nginx 负载均衡，将请求分散的打到我们的后端服务器集群中，实现负载的流量分发。从而提升整体性能、以及系统的容灾能力。 # 1.3 负载均衡与代理区别 Nginx 负载均衡与</div><div class="meta footer"><span><a href="/categories/Nginx/" itemprop="url" title="Nginx"><i class="ic i-flag"></i>Nginx</a></span></div><a href="/posts/1979768636.html" class="btn" itemprop="url" title="Nginx代理-负载均衡实践（五）">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/1601152722.html" itemprop="url" title="Nginx反向代理服务（四）"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/bEq7Jnt.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-08-27 21:56:13"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-08-27T21:56:13+08:00">2025-08-27</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>5.5k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>5 分钟</span></span></div><h3><a href="/posts/1601152722.html" itemprop="url" title="Nginx反向代理服务（四）">Nginx反向代理服务（四）</a></h3><div class="excerpt"># Nginx 反向代理服务 # 1.Nginx 代理概述 # 1.1 什么是代理 代理代理，代为办理，对于代理一词而言，我们并不陌生，在我们日常生活中常常用到。 比如代理理财、代理租房、代理收货等等 # 2. Nginx 正向代理 正向代理，(内部上网) 客户端 &lt;--&gt; 代理 -&gt; 服务端 比如：科学的方式访问 Google # 3. Nginx 反向代理 反向代理，用于公司集群架构中，客户端 -&gt; 代理 &lt;--&gt; 服务端 # 3.1 负载均衡 将用户发送的请求，通过负载均衡调度算法挑选一台合适的节点进行请求处理。 # 3.2 动静分离</div><div class="meta footer"><span><a href="/categories/Nginx/" itemprop="url" title="Nginx"><i class="ic i-flag"></i>Nginx</a></span></div><a href="/posts/1601152722.html" class="btn" itemprop="url" title="Nginx反向代理服务（四）">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/865547436.html" itemprop="url" title="Nginx基础架构LNMP（三）"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/Qf0HAza.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-08-27 21:50:04"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-08-27T21:50:04+08:00">2025-08-27</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>16k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>14 分钟</span></span></div><h3><a href="/posts/865547436.html" itemprop="url" title="Nginx基础架构LNMP（三）">Nginx基础架构LNMP（三）</a></h3><div class="excerpt"># Nginx 基础架构 LNMP # 1. LNMP 架构基本概述 # 1.1 什么是 LNMP LNMP 是一套技术的组合，L&#x3D;Linux、N&#x3D;Nginx、M&#x3D;[MySQL|Mariadb]、P&#x3D;[PHP|Python]； nginx 仅支持解析 html 文件；图片传输；视频传输，不支持 php 脚本文件； # 1.2 LNMP 实现过程 用户请求 http:&#x2F;&#x2F;hmallleasing.com&#x2F;index.php，对于 Nginx 服务而言，是无法处理 index.php 这样的脚本，那么 Nginx 该如何配置</div><div class="meta footer"><span><a href="/categories/Nginx/" itemprop="url" title="Nginx"><i class="ic i-flag"></i>Nginx</a></span></div><a href="/posts/865547436.html" class="btn" itemprop="url" title="Nginx基础架构LNMP（三）">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/3682494305.html" itemprop="url" title="Nginx常用模块（二）"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/cTCIOUC.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-08-22 21:50:04"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-08-22T21:50:04+08:00">2025-08-22</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>21k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>19 分钟</span></span></div><h3><a href="/posts/3682494305.html" itemprop="url" title="Nginx常用模块（二）">Nginx常用模块（二）</a></h3><div class="excerpt"># Nginx 常用模块 # 1. Nginx 安装部署 # 1.1 安装 Nginx 方式 安装 Nginx 软件的方式有很多种，分为如下几种 源码编译 &#x3D;&gt;Nginx (1. 版本随意 2. 安装复杂 3. 升级繁琐) epel 仓库 &#x3D;&gt;Nginx (1. 版本较低 2. 安装简单 3. 配置不易读) 官方仓库 &#x3D;&gt;Nginx (1. 版本较新 2. 安装简单 3. 配置易读，强烈推荐 # 1.2 安装 Nginx 依赖 [root@web01 ~]# yum install -y gcc gcc-c++ autoconf pcre p</div><div class="meta footer"><span><a href="/categories/Nginx/" itemprop="url" title="Nginx"><i class="ic i-flag"></i>Nginx</a></span></div><a href="/posts/3682494305.html" class="btn" itemprop="url" title="Nginx常用模块（二）">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/1697351306.html" itemprop="url" title="Nginx基础Http协议（一）"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/thNiSUi.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-08-22 21:44:55"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-08-22T21:44:55+08:00">2025-08-22</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>3.6k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>3 分钟</span></span></div><h3><a href="/posts/1697351306.html" itemprop="url" title="Nginx基础Http协议（一）">Nginx基础Http协议（一）</a></h3><div class="excerpt"># Nginx 基础 Http 协议 # 1.Http 协议介绍 # 1.1 什么是 URL 通常我们在访问一个网站页面时，请求到的内容通称为 &quot;资源&quot;。而 “资源 “这一概念非常宽泛，它可以是一份文档，一张图片，或所有其他你能够想到的格式。每个资源都由一个 URI 来进行标识；比如: http:&#x2F;&#x2F;fj.ixuyong.cn&#x2F;public&#x2F;tt.jpeg 这样的资源，我们会将该其称为 URL 地址；百度百科解释：URL 简称统一资源定位符，用来唯一地标识万维网中的某一个资源。URL 由协议、主机名称、端口以及文件名几部分构成。 #</div><div class="meta footer"><span><a href="/categories/Nginx/" itemprop="url" title="Nginx"><i class="ic i-flag"></i>Nginx</a></span></div><a href="/posts/1697351306.html" class="btn" itemprop="url" title="Nginx基础Http协议（一）">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/2889248111.html" itemprop="url" title="Vsftp服务实践"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/qJXG83x.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-08-20 22:12:00"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-08-20T22:12:00+08:00">2025-08-20</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>23k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>21 分钟</span></span></div><h3><a href="/posts/2889248111.html" itemprop="url" title="Vsftp服务实践">Vsftp服务实践</a></h3><div class="excerpt"># Vsftp 服务实践 # 一、VSFTP 概述 FTP 是 File Transfer Protocol（文件传输协议）的英文简称，用于 Internet 上的文件的双向传输。使用 FTP 来传输时，是具有一定程度的危险性， 因为数据在因特网上面是完全没有受到保护的明文传输方式。 VSFTP 是一个基于 GPL 发布的类 Unix 系统上使用的 FTP 服务器软件，它的全称是 Very Secure FTP，从名称定义上基本可以看出，这是为了解决 ftp 传输安全性问题的。 # 二、VSFTP 工作模式 # 2.1 Port 模式 FTP 客户端首先和服务器的 TCP 21 端口建立连接，</div><div class="meta footer"><span><a href="/categories/Linux/" itemprop="url" title="Linux"><i class="ic i-flag"></i>Linux</a></span></div><a href="/posts/2889248111.html" class="btn" itemprop="url" title="Vsftp服务实践">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/269104229.html" itemprop="url" title="Samba服务实践"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/jWoOIG3.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-08-19 22:12:07"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-08-19T22:12:07+08:00">2025-08-19</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>15k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>13 分钟</span></span></div><h3><a href="/posts/269104229.html" itemprop="url" title="Samba服务实践">Samba服务实践</a></h3><div class="excerpt"># Samba 服务实践 # 一、Samba 概述 SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同操作系统的计算机之间提供文件及打印机等资源的共享服务。SMB 协议是客户机 &#x2F; 服务器型协议，客户机通过该协议可以访问服务器上的共享文件系统、打印机及其他资源。如图： 1. ftp 的优缺点： 优点：文件传输、应用层协议、可跨平台 缺点：只能实现文件传输，无法实现文件系统挂载；无法直接修改服务器端文件 2. Samba 的特性： 使用 smb&#x2F;cifs 协议、可跨平台、可实现文件系统挂载、可实</div><div class="meta footer"><span><a href="/categories/Linux/" itemprop="url" title="Linux"><i class="ic i-flag"></i>Linux</a></span></div><a href="/posts/269104229.html" class="btn" itemprop="url" title="Samba服务实践">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/1922841233.html" itemprop="url" title="Rsync服务实践"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/Gw99pS9.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-08-18 20:45:48"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-08-18T20:45:48+08:00">2025-08-18</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>16k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>14 分钟</span></span></div><h3><a href="/posts/1922841233.html" itemprop="url" title="Rsync服务实践">Rsync服务实践</a></h3><div class="excerpt"># Rsync 服务实践 环境准备 主机名 IP 角色 server 192.168.40.101 rsync 服务端 client 192.168.40.102 rsync 客户 # 1.rsync 服务端 # 1.1 关闭防火墙、selinux [root@localhost ~]# hostnamectl set-hostname backup[root@localhost ~]# bash[root@backup ~]# hostnamectl set-hostname aizj_lb01[root@backup ~]# systemctl stop firew</div><div class="meta footer"><span><a href="/categories/Linux/" itemprop="url" title="Linux"><i class="ic i-flag"></i>Linux</a></span></div><a href="/posts/1922841233.html" class="btn" itemprop="url" title="Rsync服务实践">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/430579059.html" itemprop="url" title="NFS网络文件系统"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/vDfc7A2.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-08-17 21:17:29"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-08-17T21:17:29+08:00">2025-08-17</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>3.7k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>3 分钟</span></span></div><h3><a href="/posts/430579059.html" itemprop="url" title="NFS网络文件系统">NFS网络文件系统</a></h3><div class="excerpt"># NFS 网络文件系统 # 一、NFS 基本概述 NFS 是 Network File System 的缩写及网络文件系统。 NFS 的主要功能是通过” 局域网 “络让不同主机系统之间可以共享目录。 # 二、NFS 实现原理 本地文件操作方式 1. 当用户执行 mkdir 命令，BashShell 无法完成该命令操作，会将其翻译给内核。 2.Kernel 内核解析完成后会驱动对应的磁盘设备，完成创建目录的操作。 NFS 创建文件方式 1.NFS 客户端执行增、删等操作，客户端会使用不同的函数对该操作进行封装。 2.NFS 客户端会通过 TCP&#x2F;IP 的方式传递给 NFS 服务端。</div><div class="meta footer"><span><a href="/categories/Linux/" itemprop="url" title="Linux"><i class="ic i-flag"></i>Linux</a></span></div><a href="/posts/430579059.html" class="btn" itemprop="url" title="NFS网络文件系统">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/2508697220.html" itemprop="url" title="Chrony时间同步服务"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/3eNIlU2.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-08-16 19:40:03"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-08-16T19:40:03+08:00">2025-08-16</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>2.6k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>2 分钟</span></span></div><h3><a href="/posts/2508697220.html" itemprop="url" title="Chrony时间同步服务">Chrony时间同步服务</a></h3><div class="excerpt"># Chrony 时间同步服务 # 一、时间同步基本概念 时间同步就是将本地时间与互联网时间进行校对，为系统提供一个统一时间的过程。由于本地时间的计时速率、运行环境不一致性。所有本地时钟纵使在某一刻被校准了 ，一段时间后，这些本地时钟也会出现不一致。为了本地时钟再次达到相同的时间值，所以需要进行时间同步的操作。 # 二、Chrony 时间服务 # 2.1 Chrony 介绍 chrony 是基于 ntp 协议的实现时间同步服务，它既可以当做服务端，也可以充当客户端； 1、chrony 是 NTP 的替代品，能更精确的时间和更快的速度同步时钟； 2、chrony 占用系统资源少，只有被唤起时才</div><div class="meta footer"><span><a href="/categories/Linux/" itemprop="url" title="Linux"><i class="ic i-flag"></i>Linux</a></span></div><a href="/posts/2508697220.html" class="btn" itemprop="url" title="Chrony时间同步服务">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/2260957686.html" itemprop="url" title="Linux—Centos7修改网卡名称"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/o3aSHQA.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-08-15 10:40:25"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-08-15T10:40:25+08:00">2025-08-15</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>4.1k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>4 分钟</span></span></div><h3><a href="/posts/2260957686.html" itemprop="url" title="Linux—Centos7修改网卡名称">Linux—Centos7修改网卡名称</a></h3><div class="excerpt"># Linux—Centos7 修改网卡名称 首先我们先了解不同网卡名称对应的内核参数： biosdevname&#x3D;0 net.ifnames&#x3D;1：网卡名 “enps” 此内核参数一般为默认 biosdevname&#x3D;1 net.ifnames&#x3D;0：网卡名 “em*” biosdevname&#x3D;0 net.ifnames&#x3D;0：网卡名 “eth*” 本次以将网卡名命名为 eth * 格式作示例 # 1. 查看当前网卡的信息 [root@manager ~]# ifconfigens33: flags&#x3D;4163&lt;UP,</div><div class="meta footer"><span><a href="/categories/Linux/" itemprop="url" title="Linux"><i class="ic i-flag"></i>Linux</a></span></div><a href="/posts/2260957686.html" class="btn" itemprop="url" title="Linux—Centos7修改网卡名称">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/737291847.html" itemprop="url" title="Prometheus监控实战（五）"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/o1ceeNN.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-08-14 21:48:14"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-08-14T21:48:14+08:00">2025-08-14</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>17k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>15 分钟</span></span></div><h3><a href="/posts/737291847.html" itemprop="url" title="Prometheus监控实战（五）">Prometheus监控实战（五）</a></h3><div class="excerpt"># Prometheus 服务发现与 Relabel # 一. Prometheus 服务发现 # 1.1 为什么需要服务发现 Prometheus 采⽤ Pull 模型来抓取⽬标主机的指标数据，这就意味着 Prometheus 必须事先知道每个要监控的⽬标的端点地址。然后才能从对应的 Exporter 或 Instrumentation 进⾏数据抓取。对于规模较⼩，且监控的⽬标不会频繁的发⽣变动，直接使⽤ static_configs 静态配置来监控它们，就⾮常简便。 但是，当我们⾯对容器应⽤的场景时，会发现监控的这些⽬标端点可能会频繁的发⽣变化。因此使⽤静态配置⽅法可能不太适⽤了。那么 P</div><div class="meta footer"><span><a href="/categories/Prometheus/" itemprop="url" title="Prometheus"><i class="ic i-flag"></i>Prometheus</a></span></div><a href="/posts/737291847.html" class="btn" itemprop="url" title="Prometheus监控实战（五）">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/4081185382.html" itemprop="url" title="Prometheus监控实战（四）"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/o1ceeNN.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-08-13 22:03:48"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-08-13T22:03:48+08:00">2025-08-13</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>51k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>46 分钟</span></span></div><h3><a href="/posts/4081185382.html" itemprop="url" title="Prometheus监控实战（四）">Prometheus监控实战（四）</a></h3><div class="excerpt"># Prometheus 告警服务 # 一。什么是 AleartManager # 1.1 什么是 AleartManager 由于 Prometheus 本身⽆法实现告警，因此需要借助 AlertManager 来实现告警的推送。 Prometheus Server 会对已经设定好的 “告警规则” 进⾏定期评估，当检测到问题时，会⽣成相应的告警通知并发送给 AlertManager。AlertManager 则会根据告警消息所携带的 “标签” 和事先配置的 “路由规则（Routes）”，将告警消息分发⾄不同的接收器 &#x2F; 接收⼈（receivers）。例如，带有 &quot;syst</div><div class="meta footer"><span><a href="/categories/Prometheus/" itemprop="url" title="Prometheus"><i class="ic i-flag"></i>Prometheus</a></span></div><a href="/posts/4081185382.html" class="btn" itemprop="url" title="Prometheus监控实战（四）">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/4081185381.html" itemprop="url" title="Prometheus监控实战（三）"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/o1ceeNN.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-08-12 22:17:01"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-08-12T22:17:01+08:00">2025-08-12</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>93k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>1:24</span></span></div><h3><a href="/posts/4081185381.html" itemprop="url" title="Prometheus监控实战（三）">Prometheus监控实战（三）</a></h3><div class="excerpt"># Prometheus 监控实战（三） # 一. Promtheus 节点监控 # 1.1 配置 Prometheus [root@prom-node01 ~]# cat &#x2F;etc&#x2F;prometheus&#x2F;prometheus.yml# 全局段定义global: scrape_interval: 15s # 设置 Prometheus 抓取指标数据的间隔，默认为 15 秒。# rules 配置文件路径rule_files: - &quot;&#x2F;etc&#x2F;prometheus&#x2F;rules&#x2F;*.yml&quot; # 抓取指定</div><div class="meta footer"><span><a href="/categories/Prometheus/" itemprop="url" title="Prometheus"><i class="ic i-flag"></i>Prometheus</a></span></div><a href="/posts/4081185381.html" class="btn" itemprop="url" title="Prometheus监控实战（三）">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/3386060324.html" itemprop="url" title="PromQL快速入门（二）"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/oApfFnU.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-08-11 22:16:53"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-08-11T22:16:53+08:00">2025-08-11</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>34k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>31 分钟</span></span></div><h3><a href="/posts/3386060324.html" itemprop="url" title="PromQL快速入门（二）">PromQL快速入门（二）</a></h3><div class="excerpt"># PromQL 快速入门（二） # 一. PromQL 基础概念 # 1.1 什么是 PromeQL Prometheus 内置了⼀种强⼤的查询语⾔：PromQL，即 PrometheusQuery Language。PromQL 允许⽤户实时查询监控数据，并对这些数据执⾏复杂的聚合和计算操作。 在 PromQL 中，查询的结果被称为 “向量（vector）”，分为两种类型： 1、即时向量（Instant vector）：即时向量查询返回的是⼀组时间序列数据，但每个时间序列中只包含单个的最新数据点。例如：查询当前时刻服务器 1 分钟的负载，所得到的结果就是⼀个即时向量。 2、范围向量（Ra</div><div class="meta footer"><span><a href="/categories/Prometheus/" itemprop="url" title="Prometheus"><i class="ic i-flag"></i>Prometheus</a></span></div><a href="/posts/3386060324.html" class="btn" itemprop="url" title="PromQL快速入门（二）">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/1595025559.html" itemprop="url" title="Prometheus监控实战（一）"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/o1ceeNN.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-08-10 10:33:41"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-08-10T10:33:41+08:00">2025-08-10</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>26k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>24 分钟</span></span></div><h3><a href="/posts/1595025559.html" itemprop="url" title="Prometheus监控实战（一）">Prometheus监控实战（一）</a></h3><div class="excerpt"># Prometheus 监控实战（一） # 一、Prometheus 介绍 # 1.1 Prometheus 是什么 Prometheus 是由 SoundCloud 使⽤ Go 语⾔开发的时序数据库（简称 TSDB）但它的功能并⾮局限于 TSDB，因为它还⽀持对⽬标（如服务器、应⽤程序等）进⾏监控； 因此，我们也可以理解 Prometheus 是⼀款开源的 “监控系统”，但仅仅依托 Prometheus 不⾜以⽀撑整个监控系统，它需要结合⽣态内其他的组件来构建⼀个完整的 IT 监控系统。例如： AleartManager、Grafana、PushGateway 等等。 # 1.2 什么是时</div><div class="meta footer"><span><a href="/categories/Prometheus/" itemprop="url" title="Prometheus"><i class="ic i-flag"></i>Prometheus</a></span></div><a href="/posts/1595025559.html" class="btn" itemprop="url" title="Prometheus监控实战（一）">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/2041568856.html" itemprop="url" title="Prometheus监控Kubernetes"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/el5JHV9.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-07-15 10:33:49"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-07-15T10:33:49+08:00">2025-07-15</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>273k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>4:08</span></span></div><h3><a href="/posts/2041568856.html" itemprop="url" title="Prometheus监控Kubernetes">Prometheus监控Kubernetes</a></h3><div class="excerpt"># Prometheus 监控 Kubernetes # 一、监控 Kubernetes 环境准备 [root@k8s-master01 ~]# kubectl get nodesNAME STATUS ROLES AGE VERSIONk8s-master01 Ready &lt;none&gt; 46d v1.27.10k8s-master02 Ready &lt;none&gt; 46d v1.27.10k8s-master03 Ready &lt;none&gt; 46d v1.27.10k8s-n</div><div class="meta footer"><span><a href="/categories/Prometheus/" itemprop="url" title="Prometheus"><i class="ic i-flag"></i>Prometheus</a></span></div><a href="/posts/2041568856.html" class="btn" itemprop="url" title="Prometheus监控Kubernetes">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/1598774589.html" itemprop="url" title="负载均衡LVS入门与实践"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/HdLypQZ.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-06-20 22:28:55"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-06-20T22:28:55+08:00">2025-06-20</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>20k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>18 分钟</span></span></div><h3><a href="/posts/1598774589.html" itemprop="url" title="负载均衡LVS入门与实践">负载均衡LVS入门与实践</a></h3><div class="excerpt"># 负载均衡 LVS 入门与实践 # 一、 安装 MySQL5.7 #1、下载 MySQL 官方扩展源[root@db01 ~]# rpm -ivh http:&#x2F;&#x2F;repo.mysql.com&#x2F;yum&#x2F;mysql-5.7-community&#x2F;el&#x2F;7&#x2F;x86_64&#x2F;mysql57-community-release-el7-10.noarch.rpm	#2、安装 mysql5.7，文件过大可能会导致下载缓慢[root@db01 ~]# yum install mysql-community-server -y#3、</div><div class="meta footer"><span><a href="/categories/LVS/" itemprop="url" title="LVS"><i class="ic i-flag"></i>LVS</a></span></div><a href="/posts/1598774589.html" class="btn" itemprop="url" title="负载均衡LVS入门与实践">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/581151773.html" itemprop="url" title="100个运维相关技术官网汇总"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/PdlXOts.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-06-19 21:16:37"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-06-19T21:16:37+08:00">2025-06-19</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>7.8k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>7 分钟</span></span></div><h3><a href="/posts/581151773.html" itemprop="url" title="100个运维相关技术官网汇总">100个运维相关技术官网汇总</a></h3><div class="excerpt"># 100 个运维相关技术官网大汇总 # 1. 操作系统官网 名称 官网链接 Ubuntu https:&#x2F;&#x2F;ubuntu.com Debian https:&#x2F;&#x2F;www.debian.org RHEL https:&#x2F;&#x2F;www.redhat.com Rocky Linux https:&#x2F;&#x2F;rockylinux.org AlmaLinux https:&#x2F;&#x2F;almalinux.org Arch Wiki https:&#x2F;&#x2F;wiki.archlinux.</div><div class="meta footer"><span><a href="/categories/Linux/" itemprop="url" title="Linux"><i class="ic i-flag"></i>Linux</a></span></div><a href="/posts/581151773.html" class="btn" itemprop="url" title="100个运维相关技术官网汇总">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/2330853882.html" itemprop="url" title="K8S基于Jenkins实现微服务应用CICD实践（四）"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/YwPBG6p.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-06-19 20:54:54"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-06-19T20:54:54+08:00">2025-06-19</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>85k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>1:18</span></span></div><h3><a href="/posts/2330853882.html" itemprop="url" title="K8S基于Jenkins实现微服务应用CICD实践（四）">K8S基于Jenkins实现微服务应用CICD实践（四）</a></h3><div class="excerpt"># K8S 基于 Jenkins 实现微服务应用 CICD 实践（四） CI 阶段：开发人员 -&gt; 提交代码 -&gt;gitlab 仓库 -&gt;Jenkins&#x2F;CI 抓取代码 -&gt; 漏洞扫描 -&gt; 编译 -&gt; 构建镜像 -&gt; 推送 Harbor-&gt; 部署应用至 K8S 测试环境； CD 阶段：Jenkins&#x2F;CD-&gt; 拉取 Harbor 仓库对应项目镜像 -&gt; 部署应用至 K8S 测试环境； # 一、环境准备 准备好 Java 代码、Dockerfile、deploy.yaml 资源清单文件 提交到 Gitlab 服</div><div class="meta footer"><span><a href="/categories/DevOps/" itemprop="url" title="DevOps"><i class="ic i-flag"></i>DevOps</a></span></div><a href="/posts/2330853882.html" class="btn" itemprop="url" title="K8S基于Jenkins实现微服务应用CICD实践（四）">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/889219339.html" itemprop="url" title="K8S基于Jenkins实现SpringCloud微服务CI与CD实践（三）"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/YwPBG6p.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-06-18 10:28:16"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-06-18T10:28:16+08:00">2025-06-18</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>104k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>1:34</span></span></div><h3><a href="/posts/889219339.html" itemprop="url" title="K8S基于Jenkins实现SpringCloud微服务CI与CD实践（三）">K8S基于Jenkins实现SpringCloud微服务CI与CD实践（三）</a></h3><div class="excerpt"># K8S 基于 Jenkins 实现 SpringCloud 微服务 CI 与 CD 实践（三） CI 阶段：开发人员 -&gt; 提交代码 -&gt;gitlab 仓库 -&gt;Jenkins&#x2F;CI 抓取代码 -&gt; 漏洞扫描 -&gt; 编译 -&gt; 构建镜像 -&gt; 推送 Harbor-&gt; 部署应用至 K8S 测试环境； CD 阶段：Jenkins&#x2F;CD-&gt; 拉取 Harbor 仓库对应项目镜像 -&gt; 部署应用至 K8S 测试环境； # 一、环境准备 准备好 Java 代码、Dockerfile、deploy.yaml 资源清单文件</div><div class="meta footer"><span><a href="/categories/DevOps/" itemprop="url" title="DevOps"><i class="ic i-flag"></i>DevOps</a></span></div><a href="/posts/889219339.html" class="btn" itemprop="url" title="K8S基于Jenkins实现SpringCloud微服务CI与CD实践（三）">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/1366748664.html" itemprop="url" title="K8S基于Jenkins实现Java项目CI与CD实践（二）"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/07yoBPn.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-06-17 21:57:00"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-06-17T21:57:00+08:00">2025-06-17</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>39k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>35 分钟</span></span></div><h3><a href="/posts/1366748664.html" itemprop="url" title="K8S基于Jenkins实现Java项目CI与CD实践（二）">K8S基于Jenkins实现Java项目CI与CD实践（二）</a></h3><div class="excerpt"># K8S 基于 Jenkins 实现 Java 项目 CI 与 CD 实践（二） CI 阶段：开发人员 -&gt; 提交代码 -&gt;Gitlab 仓库 -&gt;Jenkins&#x2F;CI 抓取代码 -&gt; 漏洞扫描 -&gt; 编译 -&gt; 构建镜像 -&gt; 推送 Harbor-&gt; 部署应用至 K8S 测试环境； CD 阶段：Jenkins&#x2F;CD-&gt; 拉取 Harbor 仓库对应项目镜像 -&gt; 部署应用至 K8S 生产环境； # 一、提交代码 准备好 Java 代码、Dockerfile、deploy.yaml 资源清单文件 提交到 Gi</div><div class="meta footer"><span><a href="/categories/DevOps/" itemprop="url" title="DevOps"><i class="ic i-flag"></i>DevOps</a></span></div><a href="/posts/1366748664.html" class="btn" itemprop="url" title="K8S基于Jenkins实现Java项目CI与CD实践（二）">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/1208493697.html" itemprop="url" title="K8S基于Jenkins实现SpringCloud微服务CI与CD实践（一）"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/YwPBG6p.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-06-16 10:28:16"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-06-16T10:28:16+08:00">2025-06-16</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>29k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>27 分钟</span></span></div><h3><a href="/posts/1208493697.html" itemprop="url" title="K8S基于Jenkins实现SpringCloud微服务CI与CD实践（一）">K8S基于Jenkins实现SpringCloud微服务CI与CD实践（一）</a></h3><div class="excerpt"># K8S 基于 Jenkins 实现 SpringCloud 微服务 CI 与 CD 实践（一） CI 阶段：开发人员 -&gt; 提交代码 -&gt;gitlab 仓库 -&gt;Jenkins&#x2F;CI 抓取代码 -&gt; 漏洞扫描 -&gt; 编译 -&gt; 构建镜像 -&gt; 推送 Harbor-&gt; 部署应用至 K8S 测试环境； CD 阶段：Jenkins&#x2F;CD-&gt; 拉取 Harbor 仓库对应项目镜像 -&gt; 部署应用至 K8S 测试环境 # 一、部署 Harbor # 1.1 安装基础环境 [root@harbor ~]# yum rem</div><div class="meta footer"><span><a href="/categories/DevOps/" itemprop="url" title="DevOps"><i class="ic i-flag"></i>DevOps</a></span></div><a href="/posts/1208493697.html" class="btn" itemprop="url" title="K8S基于Jenkins实现SpringCloud微服务CI与CD实践（一）">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/1528713798.html" itemprop="url" title="阿里云ECS、SLB、RDS、CDN、ESS应用与实践"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/6G2DTfe.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-06-08 10:55:56"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-06-08T10:55:56+08:00">2025-06-08</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>33</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>1 分钟</span></span></div><h3><a href="/posts/1528713798.html" itemprop="url" title="阿里云ECS、SLB、RDS、CDN、ESS应用与实践">阿里云ECS、SLB、RDS、CDN、ESS应用与实践</a></h3><div class="excerpt"># 阿里云 ECS、SLB、RDS、CDN、ESS 应用与实践</div><div class="meta footer"><span><a href="/categories/Aliyun/" itemprop="url" title="Aliyun"><i class="ic i-flag"></i>Aliyun</a></span></div><a href="/posts/1528713798.html" class="btn" itemprop="url" title="阿里云ECS、SLB、RDS、CDN、ESS应用与实践">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/754945111.html" itemprop="url" title="Tomcat JVM调优实践"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/QNeI5Oz.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-06-08 10:51:57"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-06-08T10:51:57+08:00">2025-06-08</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>35k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>32 分钟</span></span></div><h3><a href="/posts/754945111.html" itemprop="url" title="Tomcat JVM调优实践">Tomcat JVM调优实践</a></h3><div class="excerpt"># Tomcat JVM 调优实践 # 一、JVM 基础架构 # 1.1 Jvm 执行过程 使用 java 编程语言开发 java 源代码，然后通过编译器把 java 编译为 java 类文件也叫字节码； 通过类加载器 ClassLoader 将字节码加载到内存中，将其放在运行时数据区中的方法区内； 然后调用执行引擎在 JVM 虚拟机中运行，然后将字节码编译成底层系统指令，在交由 CPU 执行； 同时我们在编写程序时，不可能从头到尾去实现所有代码功能，可以通过 Java API 调用本地库接口（Native Interface）当中已经有的 java 代码来实现其他的功能（比如图形库、语言等</div><div class="meta footer"><span><a href="/categories/Tomcat/" itemprop="url" title="Tomcat"><i class="ic i-flag"></i>Tomcat</a></span></div><a href="/posts/754945111.html" class="btn" itemprop="url" title="Tomcat JVM调优实践">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/4201058646.html" itemprop="url" title="Tomcat配置管理实践"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/Cll8JPP.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-06-08 10:51:48"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-06-08T10:51:48+08:00">2025-06-08</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>20k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>18 分钟</span></span></div><h3><a href="/posts/4201058646.html" itemprop="url" title="Tomcat配置管理实践">Tomcat配置管理实践</a></h3><div class="excerpt"># Tomcat 配置管理实践 # 一、OracleJdk 安装 OracleJdk 下载地址：https:&#x2F;&#x2F;www.oracle.com&#x2F;java&#x2F;technologies&#x2F;downloads&#x2F;#java8 [root@web01 ~]# tar xf jdk-8u451-linux-x64.tar.gz -C &#x2F;usr&#x2F;local[root@web01 ~]# ln -s &#x2F;usr&#x2F;local&#x2F;jdk1.8.0_451&#x2F; &#x2F;usr&#x2F;local&#x2</div><div class="meta footer"><span><a href="/categories/Tomcat/" itemprop="url" title="Tomcat"><i class="ic i-flag"></i>Tomcat</a></span></div><a href="/posts/4201058646.html" class="btn" itemprop="url" title="Tomcat配置管理实践">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/2126514413.html" itemprop="url" title="虚拟隧道网络Openvpn"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/RxKV39a.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-06-05 21:50:22"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-06-05T21:50:22+08:00">2025-06-05</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>29k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>26 分钟</span></span></div><h3><a href="/posts/2126514413.html" itemprop="url" title="虚拟隧道网络Openvpn">虚拟隧道网络Openvpn</a></h3><div class="excerpt"># 虚拟隧道网络 Openvpn # 一、什么是 VPN VPN（Virtual Private Network） 翻译过来就是虚拟专⽤⽹络，那虚拟专⽤⽹提供什么功能 将两个或多个 “不同地域 “的⽹络通过⼀条虚拟隧道的⽅式连接起来，实现互通； 在不安全的线路上提供安全的数据传输； # 二、VPN 应⽤场景 # 2.1 点对点连接 Peer-to-Peer VPN (点对点连接)，将 Internet 两台机器（公⽹地址）使⽤ VPN 连接起来，⽐如上海服务器和北京服务器的之间的数据需要相互调⽤，但是数据⼜⽐较敏感，直接通过 http 公共⽹络传输，容易被窃取。如果拉⼀条专线成本⼜太⾼。所</div><div class="meta footer"><span><a href="/categories/Openvpn/" itemprop="url" title="Openvpn"><i class="ic i-flag"></i>Openvpn</a></span></div><a href="/posts/2126514413.html" class="btn" itemprop="url" title="虚拟隧道网络Openvpn">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/570469260.html" itemprop="url" title="ELK收集Kubernetes组件日志分析与实践"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/S8XTSGP.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-06-05 19:06:21"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-06-05T19:06:21+08:00">2025-06-05</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>46k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>41 分钟</span></span></div><h3><a href="/posts/570469260.html" itemprop="url" title="ELK收集Kubernetes组件日志分析与实践">ELK收集Kubernetes组件日志分析与实践</a></h3><div class="excerpt"># ELK 收集 Kubernetes 组件日志分析与实践 # 一、ELK 创建 Namespace 和 Secrets # kubectl create ns logging# kubectl create secret docker-registry harbor-admin -n logging --docker-server&#x3D;registry.cn-hangzhou.aliyuncs.com --docker-username&#x3D;xyapples@163.com --docker-password&#x3D;passwd# 二、交付 Zookeeper 集群至 K8</div><div class="meta footer"><span><a href="/categories/ELKStack/" itemprop="url" title="ELKStack"><i class="ic i-flag"></i>ELKStack</a></span></div><a href="/posts/570469260.html" class="btn" itemprop="url" title="ELK收集Kubernetes组件日志分析与实践">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/1384812626.html" itemprop="url" title="Kubenetes部署Rabbitmq集群"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/ysB0MfV.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-05-29 20:48:49"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-05-29T20:48:49+08:00">2025-05-29</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>12k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>11 分钟</span></span></div><h3><a href="/posts/1384812626.html" itemprop="url" title="Kubenetes部署Rabbitmq集群">Kubenetes部署Rabbitmq集群</a></h3><div class="excerpt"># Kubenetes 部署 Rabbitmq 集群 # 1. 创建 RBAC 权限 # cat 01-rabbitmq-rbac.yaml apiVersion: v1kind: ServiceAccountmetadata: name: rabbitmq-cluster namespace: prod---apiVersion: rbac.authorization.k8s.io&#x2F;v1kind: Rolemetadata: name: rabbitmq-cluster namespace: prodrules:- apiGroups: [&quot;&quot;] re</div><div class="meta footer"><span><a href="/categories/Rabbitmq/" itemprop="url" title="Rabbitmq"><i class="ic i-flag"></i>Rabbitmq</a></span></div><a href="/posts/1384812626.html" class="btn" itemprop="url" title="Kubenetes部署Rabbitmq集群">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/2692178654.html" itemprop="url" title="Rabbitmq集群部署"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/a061dum.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-05-29 20:35:53"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-05-29T20:35:53+08:00">2025-05-29</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>5.7k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>5 分钟</span></span></div><h3><a href="/posts/2692178654.html" itemprop="url" title="Rabbitmq集群部署">Rabbitmq集群部署</a></h3><div class="excerpt"># Rabbitmq 集群部署 # 一、环境配置 # 1.1 关闭防火墙、Selinux systemctl disable --now firewalld setenforce 0sed -i &#39;s#SELINUX&#x3D;enforcing#SELINUX&#x3D;disabled#g&#39; &#x2F;etc&#x2F;sysconfig&#x2F;selinuxsed -i &#39;s#SELINUX&#x3D;enforcing#SELINUX&#x3D;disabled#g&#39; &#x2F;etc&#x2F;selinux&#x2F;config# 1.2</div><div class="meta footer"><span><a href="/categories/Rabbitmq/" itemprop="url" title="Rabbitmq"><i class="ic i-flag"></i>Rabbitmq</a></span></div><a href="/posts/2692178654.html" class="btn" itemprop="url" title="Rabbitmq集群部署">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/170066797.html" itemprop="url" title="消费租赁项目Kubernetes基于ELK日志分析与实践"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/Q4Mg1Vy.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-05-25 14:35:21"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-05-25T14:35:21+08:00">2025-05-25</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>64k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>58 分钟</span></span></div><h3><a href="/posts/170066797.html" itemprop="url" title="消费租赁项目Kubernetes基于ELK日志分析与实践">消费租赁项目Kubernetes基于ELK日志分析与实践</a></h3><div class="excerpt"># 消费租赁项目 Kubernetes 基于 ELK 日志分析与实践 # 一、ELK 创建 Namespace 和 Secrets # kubectl create ns logging# kubectl create secret docker-registry harbor-admin -n logging --docker-server&#x3D;registry.cn-hangzhou.aliyuncs.com --docker-username&#x3D;xyapples@163.com --docker-password&#x3D;passwd# 二、交付 Zookeeper 集</div><div class="meta footer"><span><a href="/categories/ELKStack/" itemprop="url" title="ELKStack"><i class="ic i-flag"></i>ELKStack</a></span></div><a href="/posts/170066797.html" class="btn" itemprop="url" title="消费租赁项目Kubernetes基于ELK日志分析与实践">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/626047790.html" itemprop="url" title="消费租赁系统微服务应用交付实践"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/er1zpXS.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-05-18 21:42:46"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-05-18T21:42:46+08:00">2025-05-18</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>82k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>1:15</span></span></div><h3><a href="/posts/626047790.html" itemprop="url" title="消费租赁系统微服务应用交付实践">消费租赁系统微服务应用交付实践</a></h3><div class="excerpt"># 消费租赁系统微服务应用交付实践 # 一、部署中间件 # 1.1 部署 MySQL # 1.1.1 MySQL-ConfigMap [root@k8s-master01 01-nf-flms-mysql]# cat 01-mysql-cm.yaml apiVersion: v1kind: ConfigMapmetadata: name: mysql-cm namespace: proddata: my.cnf: |- [mysqld] #performance setttings lock_wait_timeout &#x3D; 3600 open_files_</div><div class="meta footer"><span><a href="/categories/Kubernetes/" itemprop="url" title="Kubernetes"><i class="ic i-flag"></i>Kubernetes</a></span></div><a href="/posts/626047790.html" class="btn" itemprop="url" title="消费租赁系统微服务应用交付实践">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/1888662579.html" itemprop="url" title="Containerd常用命令"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/Uy68edS.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-05-14 20:29:07"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-05-14T20:29:07+08:00">2025-05-14</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>5.8k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>5 分钟</span></span></div><h3><a href="/posts/1888662579.html" itemprop="url" title="Containerd常用命令">Containerd常用命令</a></h3><div class="excerpt"># Containerd 常用命令 # 1. 安装 Containerd 1.1 配置安装源 yum install wget jq psmisc vim net-tools telnet yum-utils device-mapper-persistent-data lvm2 git -yyum-config-manager --add-repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo1.2 安装 docker-ce、containerd yu</div><div class="meta footer"><span><a href="/categories/Docker/" itemprop="url" title="Docker"><i class="ic i-flag"></i>Docker</a></span></div><a href="/posts/1888662579.html" class="btn" itemprop="url" title="Containerd常用命令">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/1490514396.html" itemprop="url" title="Redis Cluster集群部署"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/2xXk5iP.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-05-12 21:21:44"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-05-12T21:21:44+08:00">2025-05-12</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>17k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>15 分钟</span></span></div><h3><a href="/posts/1490514396.html" itemprop="url" title="Redis Cluster集群部署">Redis Cluster集群部署</a></h3><div class="excerpt"># Redis Cluster 集群部署 # 1、环境配置 # 1.1 关闭防火墙、Selinux systemctl disable --now firewalld setenforce 0sed -i &#39;s#SELINUX&#x3D;enforcing#SELINUX&#x3D;disabled#g&#39; &#x2F;etc&#x2F;sysconfig&#x2F;selinuxsed -i &#39;s#SELINUX&#x3D;enforcing#SELINUX&#x3D;disabled#g&#39; &#x2F;etc&#x2F;selinux&#x2F;config#</div><div class="meta footer"><span><a href="/categories/Redis/" itemprop="url" title="Redis"><i class="ic i-flag"></i>Redis</a></span></div><a href="/posts/1490514396.html" class="btn" itemprop="url" title="Redis Cluster集群部署">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/170573601.html" itemprop="url" title="K8s服务发布Ingress"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/3wj3hd5.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-04-26 16:52:06"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-04-26T16:52:06+08:00">2025-04-26</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>36k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>33 分钟</span></span></div><h3><a href="/posts/170573601.html" itemprop="url" title="K8s服务发布Ingress">K8s服务发布Ingress</a></h3><div class="excerpt"># 1. Ingress Nginx Controller 安装 Supported Ingress-NGINX version k8s supported version Alpine Version Nginx Version Helm Chart Version 🔄 v1.12.1 1.32, 1.31, 1.30, 1.29, 1.28 3.21.3 1.25.5 4.12.1 🔄 v1.12.0 1.32, 1.31, 1.30, 1.29, 1.28 3.21.0 1.25.5 4.12.0 🔄 v1.12.0-beta.0 1.32, 1.31, 1.</div><div class="meta footer"><span><a href="/categories/Kubernetes/" itemprop="url" title="Kubernetes"><i class="ic i-flag"></i>Kubernetes</a></span></div><a href="/posts/170573601.html" class="btn" itemprop="url" title="K8s服务发布Ingress">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/3364424907.html" itemprop="url" title="阿里云+Github构建镜像仓库"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/q5MesmM.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-04-26 16:20:14"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-04-26T16:20:14+08:00">2025-04-26</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>2.3k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>2 分钟</span></span></div><h3><a href="/posts/3364424907.html" itemprop="url" title="阿里云+Github构建镜像仓库">阿里云+Github构建镜像仓库</a></h3><div class="excerpt"># 阿里云 + github 构建镜像仓库解决 k8s.gcr.io 访问 由于 k8s.gcr.io&#x2F; 镜像仓库位于国外，国内使用 kubeadm 构建 docker 集群时无法访问相应的 docker 镜像。 # 1. 登录 Github 创建仓库 # 2. 创建 Dockerfile 仓库下面创建一个 Dockerfile，以 ingress-nginx-controller 为例下的 dockerfile 内容如下： [root@manager ~]# mkdir ingress-nginx-controller[root@manager ~]# cd ingress-n</div><div class="meta footer"><span><a href="/categories/Docker/" itemprop="url" title="Docker"><i class="ic i-flag"></i>Docker</a></span></div><a href="/posts/3364424907.html" class="btn" itemprop="url" title="阿里云+Github构建镜像仓库">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/3030097036.html" itemprop="url" title="K8S云原生存储Rook-Ceph"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/hY05dZP.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-04-24 21:43:19"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-04-24T21:43:19+08:00">2025-04-24</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>35k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>32 分钟</span></span></div><h3><a href="/posts/3030097036.html" itemprop="url" title="K8S云原生存储Rook-Ceph">K8S云原生存储Rook-Ceph</a></h3><div class="excerpt"># K8S 云原生存储 Rook-Ceph # 1. StorageClass 动态存储 StorageClass：存储类，由 K8s 管理员创建，用于动态 PV 的管理，可以链接至不同的后端存储，比如 Ceph、GlusterFS 等。之后对存储的请求可以指向 StorageClass，然后 StorageClass 会自动的创建、删除 PV。 实现方式： in-tree: 内置于 K8s 核心代码，对于存储的管理，都需要编写相应的代码。 out-of-tree：由存储厂商提供一个驱动（CSI 或 Flex Volume），安装到 K8s 集群，然后 StorageClass 只需要配置该</div><div class="meta footer"><span><a href="/categories/Kubernetes/" itemprop="url" title="Kubernetes"><i class="ic i-flag"></i>Kubernetes</a></span></div><a href="/posts/3030097036.html" class="btn" itemprop="url" title="K8S云原生存储Rook-Ceph">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/3890389502.html" itemprop="url" title="K8S持久化存储NFS+StorageClass"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/MrtgBDG.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-04-23 20:08:26"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-04-23T20:08:26+08:00">2025-04-23</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>5.9k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>5 分钟</span></span></div><h3><a href="/posts/3890389502.html" itemprop="url" title="K8S持久化存储NFS+StorageClass">K8S持久化存储NFS+StorageClass</a></h3><div class="excerpt"># K8S 持久化存储 NFS+StorageClass # 1. 搭建 NFS 服务器 #所有 K8S 节点安装 nfs-utils[root@k8s-node02 ~]# yum install nfs-utils -y #K8S-node02 节点配置 nfs 服务[root@k8s-node02 ~]# mkdir &#x2F;data&#x2F;nfs -p[root@k8s-node02 ~]# cat &#x2F;etc&#x2F;exports&#x2F;data&#x2F;nfs 192.168.1.0&#x2F;24(rw,no_root_squash)[root@k</div><div class="meta footer"><span><a href="/categories/Kubernetes/" itemprop="url" title="Kubernetes"><i class="ic i-flag"></i>Kubernetes</a></span></div><a href="/posts/3890389502.html" class="btn" itemprop="url" title="K8S持久化存储NFS+StorageClass">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/722512536.html" itemprop="url" title="K8s细粒度权限控制RBAC"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/G2Rpybo.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-04-23 20:04:03"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-04-23T20:04:03+08:00">2025-04-23</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>5k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>5 分钟</span></span></div><h3><a href="/posts/722512536.html" itemprop="url" title="K8s细粒度权限控制RBAC">K8s细粒度权限控制RBAC</a></h3><div class="excerpt"># K8s 细粒度权限控制 RBAC # 1. 创建不同权限的 clusterrole # 1.1 命令空间只读 namespace-readonly $ cat namespace-readonly.yamlapiVersion: rbac.authorization.k8s.io&#x2F;v1kind: ClusterRolemetadata: name: namespace-readonlyrules:- apiGroups: - &quot;&quot; resources: - namespaces verbs: - get - list - watch- api</div><div class="meta footer"><span><a href="/categories/Kubernetes/" itemprop="url" title="Kubernetes"><i class="ic i-flag"></i>Kubernetes</a></span></div><a href="/posts/722512536.html" class="btn" itemprop="url" title="K8s细粒度权限控制RBAC">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/176412055.html" itemprop="url" title="K8s准入控制ResourceQuota、LimitRange、QoS服务质量"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/uopNM7m.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-04-23 19:55:19"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-04-23T19:55:19+08:00">2025-04-23</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>12k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>11 分钟</span></span></div><h3><a href="/posts/176412055.html" itemprop="url" title="K8s准入控制ResourceQuota、LimitRange、QoS服务质量">K8s准入控制ResourceQuota、LimitRange、QoS服务质量</a></h3><div class="excerpt"># K8s 准入控制 ResourceQuota、LimitRange、QoS 服务质量 # 1. ResourceQuota 配置解析 ResourceQuotas 实现资源配额，避免过度创建资源，针对 namespace 进行限制。cpu 内存则是根据 pod 配置的 resources 总额进行限制，如果没有配置 resources 参数则无法限制。 apiVersion: v1kind: ResourceQuotametadata: name: resourcequota-test namespace: test labels: app: resourcequotaspec</div><div class="meta footer"><span><a href="/categories/Kubernetes/" itemprop="url" title="Kubernetes"><i class="ic i-flag"></i>Kubernetes</a></span></div><a href="/posts/176412055.html" class="btn" itemprop="url" title="K8s准入控制ResourceQuota、LimitRange、QoS服务质量">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/312010518.html" itemprop="url" title="K8s亲和力Affinity"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/UwNCnEF.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-04-20 17:59:58"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-04-20T17:59:58+08:00">2025-04-20</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>19k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>17 分钟</span></span></div><h3><a href="/posts/312010518.html" itemprop="url" title="K8s亲和力Affinity">K8s亲和力Affinity</a></h3><div class="excerpt"># K8s 亲和力 Affinity Pod 和节点之间的关系： 某些 Pod 优先选择有 ssd&#x3D;true 标签的节点，如果没有在考虑部署到其它节点； 某些 Pod 需要部署在 ssd&#x3D;true 和 type&#x3D;physical 的节点上，但是优先部署在 ssd&#x3D;true 的节点上。 Pod 和 Pod 之间的关系： 同一个应用的 Pod 不同的副本或者同一个项目的应用尽量或必须不部署在同一个节点或者符合某个标签的一类节点上或者不同的区域； 相互依赖的两个 Pod 尽量或必须部署在同一个节点上或者同一个域内。 # 1. Affinity 分类</div><div class="meta footer"><span><a href="/categories/Kubernetes/" itemprop="url" title="Kubernetes"><i class="ic i-flag"></i>Kubernetes</a></span></div><a href="/posts/312010518.html" class="btn" itemprop="url" title="K8s亲和力Affinity">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/3254599477.html" itemprop="url" title="K8s容忍和污点"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/ap2vm8T.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-04-20 15:51:58"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-04-20T15:51:58+08:00">2025-04-20</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>3.8k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>3 分钟</span></span></div><h3><a href="/posts/3254599477.html" itemprop="url" title="K8s容忍和污点">K8s容忍和污点</a></h3><div class="excerpt"># K8s 容忍和污点 Taint 指定服务器上打上污点，让不能容忍这个污点的 Pod 不能部署在打了污点的服务器上。Toleration 是让 Pod 容忍节点上配置的污点，可以让一些需要特殊配置的 Pod 能够调用到具有污点和特殊配置的节点上。 # 1. Taint 配置解析 #1.Taint 语法# kubectl taint nodes NODE_NAME TAINT_KEY&#x3D;TAINT_VALUE:EFFECT#2. 创建 Taint 示例# kubectl taint nodes k8s-node01 ssd&#x3D;true:PreferNoSchedule#3. 查</div><div class="meta footer"><span><a href="/categories/Kubernetes/" itemprop="url" title="Kubernetes"><i class="ic i-flag"></i>Kubernetes</a></span></div><a href="/posts/3254599477.html" class="btn" itemprop="url" title="K8s容忍和污点">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/3142072607.html" itemprop="url" title="K8s初始化容器、临时容器"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/zuDLXaV.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-04-19 21:07:20"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-04-19T21:07:20+08:00">2025-04-19</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>3k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>3 分钟</span></span></div><h3><a href="/posts/3142072607.html" itemprop="url" title="K8s初始化容器、临时容器">K8s初始化容器、临时容器</a></h3><div class="excerpt"># K8s 初始化容器、临时容器 # 1. 初始化容器 # 1. 1 初始化容器的用途 初始化容器主要是在主应用启动之前，做一些初始化的操作，比如创建文件、修改内核参数、等待依赖程序启动或其他需要在主程序启动之前需要做的工作。 Init 容器可以包含一些安装过程中应用容器中不存在的实用工具或个性化代码； Init 容器可以安全地运行这些工具，避免这些工具导致应用镜像的安全性降低； Init 容器可以以 root 身份运行，执行一些高权限命令； Init 容器相关操作执行完成以后即退出，不会给业务容器带来安全隐患。 # 1.2 初始化容器和 PostStart 区别 PostStart：依赖</div><div class="meta footer"><span><a href="/categories/Kubernetes/" itemprop="url" title="Kubernetes"><i class="ic i-flag"></i>Kubernetes</a></span></div><a href="/posts/3142072607.html" class="btn" itemprop="url" title="K8s初始化容器、临时容器">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/3833778957.html" itemprop="url" title="K8s计划任务Job、Cronjob"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/PxfRilI.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-04-19 21:00:21"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-04-19T21:00:21+08:00">2025-04-19</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>3k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>3 分钟</span></span></div><h3><a href="/posts/3833778957.html" itemprop="url" title="K8s计划任务Job、Cronjob">K8s计划任务Job、Cronjob</a></h3><div class="excerpt"># K8s 计划任务 Job、Cronjob # 1. Job 配置参数详解 # cat job.yaml apiVersion: batch&#x2F;v1kind: Jobmetadata: labels: job-name: echo name: echo namespace: defaultspec: #suspend: true # 1.21+ #ttlSecondsAfterFinished: 100 backoffLimit: 4 completions: 1 parallelism: 1 template: spec: container</div><div class="meta footer"><span><a href="/categories/Kubernetes/" itemprop="url" title="Kubernetes"><i class="ic i-flag"></i>Kubernetes</a></span></div><a href="/posts/3833778957.html" class="btn" itemprop="url" title="K8s计划任务Job、Cronjob">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/169153047.html" itemprop="url" title="K8s持久化存储"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/GkJetKH.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-04-18 22:25:17"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-04-18T22:25:17+08:00">2025-04-18</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>10k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>9 分钟</span></span></div><h3><a href="/posts/169153047.html" itemprop="url" title="K8s持久化存储">K8s持久化存储</a></h3><div class="excerpt"># K8s 持久化存储 # 1. Volume Container（容器）中的磁盘文件是短暂的，当容器崩溃时，kubelet 会重新启动容器，Container 会以最干净的状态启动，最初的文件将丢失。另外，当一个 Pod 运行多个 Container 时，各个容器可能需要共享一些文件。Kubernetes Volume 可以解决这两个问题。 一些需要持久化数据的程序才会用到 Volumes，或者一些需要共享数据的容器需要 volumes。 日志收集的需求需要在应用程序的容器里面加一个 sidecar，这个容器是一个收集日志的容器，比如 filebeat，它通过 volumes 共享应用程序</div><div class="meta footer"><span><a href="/categories/Kubernetes/" itemprop="url" title="Kubernetes"><i class="ic i-flag"></i>Kubernetes</a></span></div><a href="/posts/169153047.html" class="btn" itemprop="url" title="K8s持久化存储">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/3992668367.html" itemprop="url" title="K8s配置管理Configmap"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/HpeldXL.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-04-14 21:47:47"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-04-14T21:47:47+08:00">2025-04-14</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>11k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>10 分钟</span></span></div><h3><a href="/posts/3992668367.html" itemprop="url" title="K8s配置管理Configmap">K8s配置管理Configmap</a></h3><div class="excerpt"># K8s 配置管理 Configmap # 1. Configmap # 1. 1 基于 from-env-file 创建 Configmap # cat cm_env.conf podname&#x3D;nf-flms-systempodip&#x3D;192.168.1.100env&#x3D;prodnacosaddr&#x3D;nacos.svc.cluster.local#kubectl create cm cmenv --from-env-file&#x3D;.&#x2F;cm_env.conf# 1.2 基于 from-literal 创建 Configmap # kubect</div><div class="meta footer"><span><a href="/categories/Kubernetes/" itemprop="url" title="Kubernetes"><i class="ic i-flag"></i>Kubernetes</a></span></div><a href="/posts/3992668367.html" class="btn" itemprop="url" title="K8s配置管理Configmap">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/858611107.html" itemprop="url" title="K8s服务发布Service"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/JT94Mem.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-04-14 19:25:51"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-04-14T19:25:51+08:00">2025-04-14</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>2.5k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>2 分钟</span></span></div><h3><a href="/posts/858611107.html" itemprop="url" title="K8s服务发布Service">K8s服务发布Service</a></h3><div class="excerpt"># K8s 服务发布 Service # 1. Service 类型 Kubernetes Service Type（服务类型）主要包括以下几种： ClusterIP：在集群内部使用，默认值，只能从集群中访问。 NodePort：在所有安装了 Kube-Proxy 的节点上打开一个端口，此端口可以代理至后端 Pod，可以通过 NodePort 从集群外部访问集群内的服务，格式为 NodeIP:NodePort。 LoadBalancer：使用云提供商的负载均衡器公开服务，成本较高。 ExternalName：通过返回定义的 CNAME 别名，没有设置任何类型的代理，需要 1.7 或更高版本</div><div class="meta footer"><span><a href="/categories/Kubernetes/" itemprop="url" title="Kubernetes"><i class="ic i-flag"></i>Kubernetes</a></span></div><a href="/posts/858611107.html" class="btn" itemprop="url" title="K8s服务发布Service">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/108692210.html" itemprop="url" title="K8s资源调度deployment、statefulset、daemonset"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/G7MkWS8.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-04-14 19:25:00"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-04-14T19:25:00+08:00">2025-04-14</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>19k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>17 分钟</span></span></div><h3><a href="/posts/108692210.html" itemprop="url" title="K8s资源调度deployment、statefulset、daemonset">K8s资源调度deployment、statefulset、daemonset</a></h3><div class="excerpt"># K8s 资源调度 deployment、statefulset、daemonset # 1. 无状态应用管理 Deployment [root@k8s-master01 ~]# cat nginx-deploy.yaml apiVersion: apps&#x2F;v1kind: Deploymentmetadata: name: nginx-deploy labels: app: nginx-deploy annotations: app: nginx-deploy namespace: defaultspec: selector: matchLabels:</div><div class="meta footer"><span><a href="/categories/Kubernetes/" itemprop="url" title="Kubernetes"><i class="ic i-flag"></i>Kubernetes</a></span></div><a href="/posts/108692210.html" class="btn" itemprop="url" title="K8s资源调度deployment、statefulset、daemonset">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/1771242682.html" itemprop="url" title="K8s零宕机服务发布-探针"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/t9ScBwd.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-04-14 19:23:48"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-04-14T19:23:48+08:00">2025-04-14</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>6.9k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>6 分钟</span></span></div><h3><a href="/posts/1771242682.html" itemprop="url" title="K8s零宕机服务发布-探针">K8s零宕机服务发布-探针</a></h3><div class="excerpt"># K8s 零宕机服务发布 - 探针 # 1. Pod 状态及 Pod 故障排查命令 状态 说明 Pending（挂起） Pod 已被 Kubernetes 系统接收，但仍有一个或多个容器未被创建，可以通过 kubectl describe 查看处于 Pending 状态的原因 Running（运行中） Pod 已经被绑定到一个节点上，并且所有的容器都已经被创建，而且至少有一个是运行状态，或者是正在启动或者重启，可以通过 kubectl logs 查看 Pod 的日志 Succeeded（成功） 所有容器执行成功并终止，并且不会再次重启，可以通过 kubectl logs</div><div class="meta footer"><span><a href="/categories/Kubernetes/" itemprop="url" title="Kubernetes"><i class="ic i-flag"></i>Kubernetes</a></span></div><a href="/posts/1771242682.html" class="btn" itemprop="url" title="K8s零宕机服务发布-探针">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/3071070979.html" itemprop="url" title="一键永久激活Window、office教程"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/ZCErObQ.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-04-10 21:32:09"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-04-10T21:32:09+08:00">2025-04-10</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>504</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>1 分钟</span></span></div><h3><a href="/posts/3071070979.html" itemprop="url" title="一键永久激活Window、office教程">一键永久激活Window、office教程</a></h3><div class="excerpt"># 一键永久激活 Window、office 教程 1、按下 Win 键 + R，调出运行对话框，输入 powershell 并回车，启动命令提示符窗口。接着输入以下指令执行激活： irm https:&#x2F;&#x2F;get.activated.win | iex 该脚本包含四个功能：首个命令用于 Windows 系统永久激活，第二个用于 Office 永久激活，第三个将系统有效期延长至 2038 年，第四个则实现每 180 天自动循环激活。 2. 我们再次使用 Windows 徽标 + R 快捷键打开运行框，输入 slmgr.vbs&#x2F;xpr 就可以看到系统已经永久激活了。</div><div class="meta footer"><span><a href="/categories/Windows/" itemprop="url" title="Windows"><i class="ic i-flag"></i>Windows</a></span></div><a href="/posts/3071070979.html" class="btn" itemprop="url" title="一键永久激活Window、office教程">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/985149017.html" itemprop="url" title="二进制高可用安装K8S集群"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/ANhhfk8.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-04-10 20:58:40"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-04-10T20:58:40+08:00">2025-04-10</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>55k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>50 分钟</span></span></div><h3><a href="/posts/985149017.html" itemprop="url" title="二进制高可用安装K8S集群">二进制高可用安装K8S集群</a></h3><div class="excerpt"># 二进制高可用安装 K8s 集群 # 1. 基本配置 # 1.1 基本环境配置 主机名 IP 地址 说明 k8s-master01 ~ 03 192.168.1.71 ~ 73 master 节点 * 3 &#x2F; 192.168.1.70 keepalived 虚拟 IP（不占用机器） k8s-node01 ~ 02 192.168.1.74&#x2F;75 worker 节点 * 2 请统一替换这些网段，Pod 网段和 service 和宿主机网段不要重复！！！ * 配置信息 * 备注 系统版本 Rocky Linux 8&#x2F;9</div><div class="meta footer"><span><a href="/categories/Kubernetes/" itemprop="url" title="Kubernetes"><i class="ic i-flag"></i>Kubernetes</a></span></div><a href="/posts/985149017.html" class="btn" itemprop="url" title="二进制高可用安装K8S集群">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/2628187572.html" itemprop="url" title="MySQL运维DBA应用与实践"><img loading="eager" decoding="async" src="https://s21.ax1x.com/2025/04/09/pEgOYIf.jpg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-04-09 22:02:40"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-04-09T22:02:40+08:00">2025-04-09</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>55k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>50 分钟</span></span></div><h3><a href="/posts/2628187572.html" itemprop="url" title="MySQL运维DBA应用与实践">MySQL运维DBA应用与实践</a></h3><div class="excerpt"># MySQL 运维 DBA 应用与实践 # 1. 日志 在任何一种数据库中，都会有各种各样的日志，这些日志记录了数据库运行的各个方面。可以帮助数据库管理员追踪数据库曾经发生的一些事情。 对于 MySQL 数据库，提供了四种不同的日志帮助我们追踪。 错误日志 二进制日志 查询日志 慢查询日志 # 1.1 错误日志 错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld (MySQL 服务) 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。 该日志是默认开启的，默认存放目录 &#x2F</div><div class="meta footer"><span><a href="/categories/MySQL/" itemprop="url" title="MySQL"><i class="ic i-flag"></i>MySQL</a></span></div><a href="/posts/2628187572.html" class="btn" itemprop="url" title="MySQL运维DBA应用与实践">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/2771271649.html" itemprop="url" title="云原生K8s安全专家CKS认证考题详解"><img loading="eager" decoding="async" src="https://s21.ax1x.com/2025/04/09/pEgL78g.jpg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-04-09 21:38:39"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-04-09T21:38:39+08:00">2025-04-09</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>19k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>17 分钟</span></span></div><h3><a href="/posts/2771271649.html" itemprop="url" title="云原生K8s安全专家CKS认证考题详解">云原生K8s安全专家CKS认证考题详解</a></h3><div class="excerpt">该文章已被加密, 请输入密码查看。</div><div class="meta footer"><span><a href="/categories/Kubernetes/" itemprop="url" title="Kubernetes"><i class="ic i-flag"></i>Kubernetes</a></span></div><a href="/posts/2771271649.html" class="btn" itemprop="url" title="云原生K8s安全专家CKS认证考题详解">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/1414180692.html" itemprop="url" title="Redis集群（主从+哨兵）模式"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/ceXptpc.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-04-09 19:50:06"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-04-09T19:50:06+08:00">2025-04-09</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>18k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>16 分钟</span></span></div><h3><a href="/posts/1414180692.html" itemprop="url" title="Redis集群（主从+哨兵）模式">Redis集群（主从+哨兵）模式</a></h3><div class="excerpt"># Redis 集群（主从 + 哨兵）模式 # 一、什么是 redis 主从复制？ 主从复制，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为主节点 (master)，后者称为从节点 (slave), 数据的复制是单向的，只能由主节点到从节点。master 以写为主，slave 以读为主。 # 二、主从复制的作用 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供</div><div class="meta footer"><span><a href="/categories/Redis/" itemprop="url" title="Redis"><i class="ic i-flag"></i>Redis</a></span></div><a href="/posts/1414180692.html" class="btn" itemprop="url" title="Redis集群（主从+哨兵）模式">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/3166738000.html" itemprop="url" title="Kubeadm高可用安装K8s集群"><img loading="eager" decoding="async" src="https://s21.ax1x.com/2025/04/09/pEgIg0S.jpg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-04-09 18:28:34"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-04-09T18:28:34+08:00">2025-04-09</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>33k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>30 分钟</span></span></div><h3><a href="/posts/3166738000.html" itemprop="url" title="Kubeadm高可用安装K8s集群">Kubeadm高可用安装K8s集群</a></h3><div class="excerpt"># Kubeadm 高可用安装 K8s 集群 # 1. 基本配置 # 1.1 基本环境配置 主机名 IP 地址 说明 k8s-master01 ~ 03 192.168.1.71 ~ 73 master 节点 * 3 &#x2F; 192.168.1.70 keepalived 虚拟 IP（不占用机器） k8s-node01 ~ 02 192.168.1.74&#x2F;75 worker 节点 * 2 请统一替换这些网段，Pod 网段和 service 和宿主机网段不要重复！！！ * 配置信息 * 备注 系统版本 Rocky Linux 8&#x2F</div><div class="meta footer"><span><a href="/categories/Kubernetes/" itemprop="url" title="Kubernetes"><i class="ic i-flag"></i>Kubernetes</a></span></div><a href="/posts/3166738000.html" class="btn" itemprop="url" title="Kubeadm高可用安装K8s集群">more...</a></div></article><article class="item"><div class="cover"><a href="/posts/3071070978.html" itemprop="url" title="企业级私有仓库Harbor搭建"><img loading="eager" decoding="async" src="https://wp-cdn.4ce.cn/v2/4mGonrd.jpeg" alt="article cover"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2025-03-30 16:17:00"><span class="icon"><i class="ic i-calendar"></i></span><time itemprop="dateCreated datePublished" datetime="2025-03-30T16:17:00+08:00">2025-03-30</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span>4k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span>4 分钟</span></span></div><h3><a href="/posts/3071070978.html" itemprop="url" title="企业级私有仓库Harbor搭建">企业级私有仓库Harbor搭建</a></h3><div class="excerpt"># 企业级私有仓库 Harbor 企业部署 Kuberetes 集群环境之后，我们就可以将原来在传统虚拟机上运行的业务，迁移到 kubernetes 上，让 Kubernetes 通过容器的方式来管理。而一旦我们需要将传统业务使用容器的方式运行起来，就需要构建很多镜像，那么这些镜像就需要有一个专门的位置存储起来，为我们提供镜像上传和镜像下载等功能。但我们不能使用阿里云或者 Dockerhub 等仓库，首先拉取速度比较慢，其次镜像的安全性无法保证，所以就需要部署一个私有的镜像仓库来管理这些容器镜像。同时该仓库还需要提供高可用功能，确保随时都能上传和下载可用的容器镜像。 # 1、关闭防火墙、Sel</div><div class="meta footer"><span><a href="/categories/Harbor/" itemprop="url" title="Harbor"><i class="ic i-flag"></i>Harbor</a></span></div><a href="/posts/3071070978.html" class="btn" itemprop="url" title="企业级私有仓库Harbor搭建">more...</a></div></article></div></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="Xu Yong" src="/assets/avatar.png"><p class="name" itemprop="name">Xu Yong</p><div class="description" itemprop="description">专注于 Linux 运维、云计算、云原⽣等技术</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">64</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">16</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">19</span><span class="name">标签</span></a></div></nav><div class="social"><a target="_blank" rel="noopener" href="https://github.com/xyapples" class="item github" title="https:&#x2F;&#x2F;github.com&#x2F;xyapples"><i class="ic i-github"></i></a><a target="_blank" rel="noopener" href="https://gitee.com/chinagei" class="item gitee" title="https:&#x2F;&#x2F;gitee.com&#x2F;chinagei"><i class="ic i-gitee"></i></a><a href="mailto:373370405@qq.com" class="item email" title="mailto:373370405@qq.com"><i class="ic i-envelope"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-about"></i>关于</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Kubernetes/" title="分类于Kubernetes">Kubernetes</a></div><span><a href="/posts/170573601.html">K8s服务发布Ingress</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Kubernetes/" title="分类于Kubernetes">Kubernetes</a></div><span><a href="/posts/1771242682.html">K8s零宕机服务发布-探针</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Nginx/" title="分类于Nginx">Nginx</a></div><span><a href="/posts/3682494305.html">Nginx常用模块（二）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Nginx/" title="分类于Nginx">Nginx</a></div><span><a href="/posts/1979768636.html">Nginx代理-负载均衡实践（五）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Nginx/" title="分类于Nginx">Nginx</a></div><span><a href="/posts/1601152722.html">Nginx反向代理服务（四）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Kubernetes/" title="分类于Kubernetes">Kubernetes</a></div><span><a href="/posts/108692210.html">K8s资源调度deployment、statefulset、daemonset</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ELKStack/" title="分类于ELKStack">ELKStack</a></div><span><a href="/posts/170066797.html">消费租赁项目Kubernetes基于ELK日志分析与实践</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Openvpn/" title="分类于Openvpn">Openvpn</a></div><span><a href="/posts/2126514413.html">虚拟隧道网络Openvpn</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Kubernetes/" title="分类于Kubernetes">Kubernetes</a></div><span><a href="/posts/3030097036.html">K8S云原生存储Rook-Ceph</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Nginx/" title="分类于Nginx">Nginx</a></div><span><a href="/posts/2279050448.html">Nginx代理-动静分离(九)</a></span></li></ul></div><div class="rpost pjax"><h2>最新评论</h2><ul class="leancloud-recent-comment" id="new-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2022 -<span itemprop="copyrightYear">2025</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">Xu Yong @ LinuxSre云原生</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">1.7m 字</span><span class="post-meta-divider"> | </span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">25:01</span></div><div class="powered-by">基于 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & Theme.<a target="_blank" rel="noopener" href="https://github.com/theme-shoka-x/hexo-theme-shokaX/">ShokaX</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL = {
    ispost: false,
        path: ``,
        favicon: {
        show: `（●´3｀●）やれやれだぜ`,
        hide: `(´Д｀)大変だ！`
    },
    search: {
        placeholder: "文章搜索",
        empty: "关于 「 ${query} 」，什么也没搜到",
        stats: "${time} ms 内找到 ${hits} 条结果"
    },
    copy_tex: false,
    katex: false,
    mermaid: false,
    audio: undefined,
    fancybox: true,
    nocopy: false,
    outime: true,
    template: `<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>`,
    quiz: {
        choice: `单选题`,
        multiple: `多选题`,
        true_false: `判断题`,
        essay: `问答题`,
        gap_fill: `填空题`,
        mistake: `错题备注`
    },
    ignores: [
        (uri) => uri.includes('#'),
        (uri) => new RegExp(LOCAL.path + '$').test(uri),
            []
    ]
};</script><script src="https://s4.zstatic.net/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha384-ZvpUoO&#x2F;+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn&#x2F;6Z&#x2F;hRTt8+pR6L4N2" crossorigin="anonymous" fetchpriority="high"></script><script src="/js/siteInit.js?v=0.4.17" type="module" fetchpriority="high" defer></script></body></html><!-- rebuild by hrmmi -->